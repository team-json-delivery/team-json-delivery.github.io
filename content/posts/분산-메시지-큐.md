---
title: '분산 메시지 큐를 설계하면 넌 X니어'
date: 2024-02-27T09:00:00+09:00
author: "junho3"
cover:
  image: "/images/message-queue/cover.png"
---

# 분산 메시지 큐 설계해보기

MSA(Microservice Architecture)가 아키텍처 설계의 트랜드로 자리잡으면서 메시지 큐는 시스템 구성의 핵심요소가 되었습니다.  
이번 글에서는 `가상 면접 사례로 배우는 대규모 시스템 설계 기초 2 4장 분산 메시지 큐`를 소개하려고 합니다.  
(메세지 큐를 구성하는 요소가 방대한 만큼 세부 개념에 대한 자세한 설명은 넘어가겠습니다.)  

---

본격적인 설계에 앞서 메시지 큐의 기능을 생각해봅시다.

```
1. 프로듀서는 메시지 큐에 메시지를 보낼 수 있어야 합니다.  
2. 컨슈머는 메시지 큐를 통해 메시지를 수신할 수 있어야 합니다.  
3. 하나의 메시지를 서로 다른 컨슈머가 수신할 수 있어야 합니다.  
4. 메시지가 생산된 순서대로 소비될 수 있도록 순서를 보장해야 합니다.  
5. 오래된 이력 데이터는 삭제될 수 있습니다.  
6. 메시지 크기는 킬로바이트 수준입니다.  
7. 메시지는 최소 한 번, 최대 한 번, 정확히 한 번 가운데 설정할 수 있어야 합니다.` 
```

메시지 큐의 비기능 요구사항은 3가지가 있습니다.

```
1. 높은 대역폭과 낮은 전송 지연 중 하나를 설정으로 선택 가능해야 합니다.  
2. 메시지 양이 급증해도 처리 가능해야 합니다.  
3. 데이터는 디스크에 보관되어야 하며 여러 노드에 복제되어야 합니다.  
```

> Kafka와 RabbitMQ의 차이점은 무엇인가요?  
> https://aws.amazon.com/ko/compare/the-difference-between-rabbitmq-and-kafka/

----

다음으로 프로듀서에서 발행한 메시지가 컨슈머까지 어떻게 전달되는지 흐름을 생각해봅시다.  
책에서는 `일대일 모델`부터 단계적으로 소개하고 있지만, 이 글에서는 `발행-구독 모델` 기반의 최종 모습만 소개하겠습니다.  

![flow.png](..%2F..%2Fstatic%2Fimages%2Fmessage-queue%2Fflow.png)

```
1. 주문 서비스(프로듀서)가 주문완료 이벤트 메시지를 발행합니다.  
2. 메시지가 주문완료 토픽에 도착합니다.  
3. 토픽에 도착한 메시지는 라운드 로빈 등의 방식으로 파티션에 분배됩니다.  
4. 주문완료 토픽을 구독하고 있는 배송 컨슈머와 주문완료 알림톡 컨슈머는 수신 받은 메시지를 처리합니다.  
```

위 이미지와 같이 프로듀서가 토픽에 메시지를 발행하고, 컨슈머 그룹이 토픽(파티션)의 메시지를 구독한다면 요구사항 1~3번을 달성할 수 있습니다.  

> Kafka에서 파티션 증가 없이 동시 처리량을 늘리는 방법 - Parallel Consumer  
> https://d2.naver.com/helloworld/7181840

----

메시지의 순서는 어떻게 보장할 수 있을까요?  

파티션은 FIFO 큐처럼 동작하므로 같은 파티션 안에서는 메시지 순서를 보장할 수 있습니다.  
하지만 토픽 관점에서는 순서를 보장할 수 없기 때문에 메시지에 키를 할당해야 합니다.

![message-key.png](..%2F..%2Fstatic%2Fimages%2Fmessage-queue%2Fmessage-key.png)

위 이미지처럼 같은 키를 가진 메시지를 같은 파티션으로 보낸다면 키를 가진 메시지는 순서를 보장할 수 있게 됩니다.  
(물론, 메시지 키를 할당하여도 토픽 관점에서 완벽한 순서 보장은 어렵습니다.)

----

데이터의 장기 보관 요구사항을 만족하면서 높은 대역폭을 제공하려면 데이터 저장소와 적재 방식을 고민해야 합니다.  

메시지 큐는 읽기와 쓰기가 대규모로 빈번하게 일어나기 때문에 파일에 저장하는 것이 적합합니다.  
책에서는 `쓰기 우선 로그(Write-Ahead Log, WAL)`을 소개하고 있는데, 새로운 항목이 추가되기만 하는 일반적인 파일 구조입니다.  
또한, 파일이 무한정 커질 것을 대비하여 `세그먼트 단위`로 파일을 분할해야 합니다.  

![storage.png](..%2F..%2Fstatic%2Fimages%2Fmessage-queue%2Fstorage.png)

위와 같이 토픽의 파티션 하위에 세그먼트별로 WAL을 관리한다면, 용량 한계에 도달하거나 보관 기간이 만료된 오래된 세그먼트 파일을 삭제할 수 있습니다.  

책에서는 `회전 디스크 사용`과 `배치 처리` 등 I/O를 줄이는 방법도 소개하고 있습니다.  

----

메시지 큐는 내부적으로 다양한 메타 정보를 관리해야 합니다.  

```
- 파티션에 할당된 컨슈머 정보  
- 컨슈머가 읽어간 마지막 메시지의 오프셋  
- 토픽 설정이나 속성 정보  
- 메시지 및 사본 등 기타 정보  
```

위와 같은 정보들은 높은 일관성을 요구하므로 `Apache ZooKeeper` 같은 키-값 저장소를 사용하는 것이 적합합니다.  

![zookeeper.png](..%2F..%2Fstatic%2Fimages%2Fmessage-queue%2Fzookeeper.png)

또한, 주키퍼는 `브로커의 리더 선출` 과정을 돕기도 합니다.  

> Kafka는 Zookeeper를 Kraft로 전환하는 작업을 하고 있습니다.  
> 
> KIP-833: Mark KRaft as Production Ready  
> https://cwiki.apache.org/confluence/display/KAFKA/KIP-833%3A+Mark+KRaft+as+Production+Ready  
> 
> Kafka’s Shift from ZooKeeper to Kraft 
> https://www.baeldung.com/kafka-shift-from-zookeeper-to-kraft  

----

분산 시스템에서 하드웨어 장애가 발생할 수 있으므로 데이터 유실을 막고 가용성을 보장하기 위해 `복제(Replication)`를 제공해야 합니다.  

![replication.png](..%2F..%2Fstatic%2Fimages%2Fmessage-queue%2Freplication.png)

리더 파티션과 사본 파티션이 있으며 리더와 사본은 서로 다른 브로커에 존재합니다.  
프로듀서는 리더 파티션에게만 메시지를 발행합니다.  
사본 파티션은 리더 파티션을 동기화합니다.   
리더 파티션은 사본 파티션의 동기화를 체크하고 프로듀서에 `메시지 수신 응답(Ack)`을 합니다.  

Ack 설정은 메시지큐의 성능과 영속성 사이에서 타협을 해야합니다.  
- `Ack=all`
  - 모든 사본 파티션이 동기화를 해야하므로 메시지 유실 없음
  - 느린 응답
  - 송금, 주문 등 데이터가 유실되면 안되는 경우
- `Ack=1`
  - 리더 파티션이 메시지를 저장하고 Ack를 하므로 리더 파티션 장애 발생 시 메시지 유실
- `Ack=0`
  - Ack를 기다리지 않으므로 언제든지 메시지 유실 발생 가능
  - 빠른 응답
  - 로그, 지표 등 데이터가 유실되도 상관 없는 경우

----

TODO 최소 한 번, 최대 한 번, 정확히 한 번

