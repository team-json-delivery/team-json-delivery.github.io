---
title: '주변 맛집을 찾으려면 어떻게 해야 검색이 빠를까?'
date: 2024-01-11T06:27:22+09:00
author: "taetaetae"

cover:
  image: "/images/system-design-interview-proximity-service/cover.png"
---

　맛집을 찾으려 포털사이트에서 키워드로 검색하는 경우가 있다. "중식 맛집" 또는 "분위기 좋은 카페" 같은 특정 키워드로 검색을 하게 되면 블로그 후기를 본다거나 지도 서비스를 활용하여 어디에 있는지 위치를 확인한다. 블로그 후기의 경우 수많은 웹문서들을 검색 엔진이 미리 색인을 해두고 검색 키워드에 따라 결과를 보여주는 형태라고 가볍게 추측해볼수 있을것 같은데 지도상에 어디에 지점이 있는지 알려주는 지도 서비스에서는 어떻게 위치 기반으로 검색을 할 수 있을까? 단순히 위경도 기준으로 쿼리 돌려 조회하면 되겠지 싶다가도 국내를 넘어 글로벌 지도 서비스까지 생각해보면 그 양이 어마어마 할텐데 1초 이내로 검색이 빠르게 되는걸 보면 그저 대단하다 라고 생각하기엔 내부 구현이 궁금해진다. 

　이번 글에서는 [가상 면접 사례로 배우는 대규모 시스템 설계 기초 2](https://product.kyobobook.co.kr/detail/S000211656186)의 "1장 근접성 서비스"라는 주제를 스터디하고 정리해보고자 한다. 위경도 좌표 기반의 검색이 어떻게 이루어 지고 어떤 측면을 고민하고 설계를 해야 하는지에 대한 내용이다. 물론, 국내를 비롯한 해외 지도 서비스들이 이 글에서 이야기 하고 있는 방식을 그대로 차용하진 않았을테고 또한 각 서비스마다(공개하기 어려운) 약간의 차이점이 있을수도 있겠지만 이렇게 상상을 해보는 과정에서 여러가지를 배울수 있을꺼라 기대해 본다.

---

## 1단계 : 문제 이해 및 설계 범위 확정
　설계를 잘하기 위해서는 구현해야할 상황을 잘 파악하고 범위를 좁히는 것이 선행되어야 한다. 그렇지 않으면 오버 엔지니어링이 되거나 구현해야할 핵심과 가치에 벗어나는 설계가 될 수 있다. 크게 "기능 요구사항"과 "비기능 요구사항"으로 구분지어 범위를 정리해볼수 있다.

### 기능 요구사항
　사용자의 위치(위/경도)와 검색 반경 정보에 매치되는 사업장(지점)을 조회되어야 하고 사업장 소유주는 사업장의 정보를 추가, 수정, 삭제를 할 수 있어야 한다. 사업장의 변경 정보의 비용이 비즈니스 가치보다 크지 않기 때문에 실시간으로 반영 될 필요는 없다. 고객(사용자)는 사업장의 상세 정보를 조회가 가능해야 한다.
### 비기능 요구사항
　낮은 Latency로 신속하게 검색이 되어야 하고 사용자의 위치정보나 사생활 보호 법안을 준수해야 한다. 인구 밀집 지역의 트래픽도 감당 가능해야 하기에 고가용성(high availability) 및 규모 확장성(scalability)을 고려해야 한다. 

　이를 바탕으로 개략적인 규모 추정을 해보면 다음과 같다. 일간 능동 사용자(DAU, daily active user)는 1억명, 등록된 사업장 수는 2억이라고 가정하면,

QPS (Query per Second) 계산 
- 1일 = 24시간 * 60분 *60초 = 86400초 ⇒ 대략 10^5초 
- 한 사용자는 하루에 5회 검색 시도 
- QPS ⇒ (1억 * 5) / 10^5 = 5,000

---
## 2단계: 개략적 설계안 제시 및 동의 구하기
### API 설계

　특정 검색 기준에 맞는 사업장 목록을 반환하는 API는 아래의 정보로 구성해 볼 수 있다.
- Request : GET /v1/search/nearby?latitude={}&longitude={}&radius={}
- Response
  ```json
  {
    "total": 10,
    "businesses": [{business object}] // 사업장을 표현하는 객체 
  }
  ```

그리고 사업장에 관련된 API 들은 다음처럼 구성해볼수 있다.

- GET /vi/businesses/:id ⇒ 특정 사업장 상세 정보 반환
- POST /v1/businesses ⇒ 새로운 사업장 추가
- PUT /v1/businesses/:id ⇒ 사업장 정보 갱신
- DELETE /v1/businesses/:id ⇒ 사업장 삭제

### 데이터 모델
　요청의 형태를 들여다 보면 데이터 모델을 결정하는데 도움이 될수 있다. 해당 서비스의 특성상 읽기 비율이 쓰기 비율보다 월등이 높을것으로 예상되고 (읽기 요청 : 주변 사업장 검색, 사업장 정보 확인) 이렇게 읽기 빈도가 압도적으로 높은 경우에는 MySQL 같은 관계형 데이터베이스가 바람직 할 수 있다고 한다.
> 읽기 빈도가 높은 경우에 관계형 데이터베이스가 더 좋은지에 대한 설명이 없어 아쉬웠다. 저자의 의견과는 반대로 읽기 빈도가 높은 경우 RDBMS보다는 NoSQL이 읽기 처리에 강점이 있다고 생각한다. 이 책에서는 단순히 데이터베이스만 보고 이야기 했던게 아니라 샤딩이나 복제 데이터베이스(주-부)같은 부가 기능들을 활용하기 위해서 빌드업을 한건 아닐까 생각을 해본다. 아래는 SQL vs NoSQL에 대한 아티클. 
> - [https://velog.io/@park2348190/논문번역-SQL-vs-NoSQL-A-Performance-Comparison](https://velog.io/@park2348190/논문번역-SQL-vs-NoSQL-A-Performance-Comparison)
> - [https://stackoverflow.com/questions/9702643/mysql-vs-mongodb-1000-reads](https://stackoverflow.com/questions/9702643/mysql-vs-mongodb-1000-reads)

　크게 사업장 상세 정보를 다루는 "사업장" 테이블과 위치 정보 관련 연산의 효율성을 높이는데 사용되는 "지리적 위치" 색인 테이블을 생각해 볼 수 있다.

### 개략적 설계
　시스템은 크게 LBS(Location Based Service, 위치기반 서비스)와 Businesses 두개의 컴포넌트로 구분된다. 가장 전면에 위치되는 로드밸런서는 유입 트래픽을 자동으로 각 서비스에 분산시킨다. 일반적으로 DNS로 단일 진입점을 만들고 URI에 따라 어느 서비스로 전달할지 결정하게 된다.

　위치기반 서비스는 시스템의 핵심 부분이며, 주어진 위치와 반경 정보를 이용해 주변 사업장을 검색한다. 쓰기 요청이 없는, 읽기 요청만 빈번하게 발생하는 서비스로 QPS가 높고 특정 시간대의 인구 밀집 지역일수록 그 경향이 심하게 된다. 다행히 무상태(stateless) 서비스이므로 수평적 규모 확장이 쉬운 특징이 있다. 사업장 서비스에서는 사업장 소유주가 사업장 정보를 CUD(Create/Update/Delete)를 하게 되고 고객이 사업장 정보를 조회한다. 특정 시간대에 QPS가 높아지는 경향이 있다.

　데이터베이스 클러스터는 주-부(primary-secondary) 데이터베이스 형태로 구성이 가능하다. 주 데이터베이스는 쓰기 요청을 처리하며, 사본 데이터베이스는 읽기 요청을 처리하여 부하를 분산 시키고 주 데이터베이스에 대한 replication에 지연이 있을 수 있으나 실시간으로 갱신될 필요가 적기 때문에 서비스 로직상 문제는 크리티컬하지 않는다고 판단한다. 

　두 서비스 모두 무상태 서비스이므로 특정 시간대에 몰리는 트래픽에는 확장, 유휴 시간에는 축소로 대응할 수 있다. 또한 시스템을 클라우드에 둔다면 여러 지역, 여러 가용성 구역에 서버를 두어 가용성을 높일 수 있다.
> 최근 회사에서 리소스 효율화 측면으로 컨테이너 기반의 서버들을 전수조사를 하였다. 너무 과하게 설정된 시스템 자원들에 대해 점검하고 축소하거나 HPA(Horizontal Pod Autoscaling)를 설정하여 트래픽이 많을때만 확장하여 사용하도록 했는데 운영환경에서 사용이 적은 새벽시간이나 개발환경의 경우 퇴근 또는 주말에는 자원을 최소화 하여 그 비용조차 아끼려는 노력을 해볼 수 있을 것 같다.


### 주변 사업장 검색 알고리즘
　어쩌면 이 챕터의 핵심이라 이야기 할 수 있는 부분이다. 대부분 geohash in redis나 PostGIS가 설치된 Postgres를 활용하지만 지리적 위치 색인이 어떻게 동작하는지에 대한 방법들을 알아보자.

#### 방안 1 : 2차원 검색
　간단히 위도와 경도를 반경 기준으로 계산하여 쿼리로 질의하는 방식이다. 이는 테이블 전부를 읽어야 하므로 효율적이지 못할뿐더러 색인을 한다고 해도 데이터가 방대하여 효율이 썩 좋지는 않다.
```sql
SELECT business_id, latitude, longitude
FROM business
WHERE (latitude BETWEEN {:my_lat} - radius AND {:my_lat} + radius)
AND (longitude BETWEEN {:my_long} - radius AND {:my_long} + radius
```

#### 방안 2 : 균등격자
　지도를 단순히 작은 격자들로 나누는 방법인데 사업장 분포가 균등하지 않다는 문제가 있다. 태평양 한가운데에는 사업장이 없고, 뉴욕에는 너무 많은 사업장이 존재한다. 지역에 따라 격자의 크기를 다르게 만드는 방법이 있을 수 있지만 이또한 기준이 지역마다 모호하다. 더불어 인접 격자를 찾기 까다로울 수 있다.

#### 방안 3 : 지오해시 (Geohash)
　간단하게 말해서 2차원의 위도 경도를 1차원의 문자열로 재생성한 것이라 보면 된다. 세계지도를 단계별로 사분면으로 나누고 이를 재귀적으로 반복하는 형태이다. 격자를 여러 단계로 나누는 정밀도(precision)는 12단계가 있는데 1단계(5,000km x 5,000km)부터 12단계(3.7cm x 1.9cm)중 적절한 정밀도를 선택해서 구현한다. 대게 잘 동작하지만 격자 가장자리 이슈가 있는데 일반적으로 인근 격자는 같은 접두어를 가지지만 적도의 위/아래 나, 자오선상의 양쪽으로 갈라지는 경우를 말한다. 아래와 같은 단순한 SQL 질의문을 사용하면 주변 모든 사업장을 가져올 수 있지만 가깝게 배치된 모든 사업장을 조회할수는 없다.
```sql
SELECT * FROM geohash_index WHERE geohash LIKE "9q8zn%"
  ```
이 문제는 인접한 모든 격자를 함께 가져오는 방법으로 해결이 가능하다. 현재 cell 인근의 격자에 대한 hash 연산으로 상수 시간에 가능한 연산이기 때문이다. 

　또 다른 이슈로 표시할 사업장이 충분하지 않는다는 이슈가 있다. 이때는 주어진 사업장만 반환하는 것으로 기능을 한정 짓거나 hash의 마지막 비트를 삭제하면서 geohash 값을 쉽게 키워서 검색할 수 있다.
> https://www.movable-type.co.uk/scripts/geohash.html

　지오해시는 통상적으로 base32을 사용한다. 예시로 계산을 해보면, 정밀도가 6이라 가정했을때 구글 본사의 지오해시는 10011101001001100011111111110 : 9q9hvu 가 되고 메타 본사의 지오해시는 10011101001001100111000111011 : 9q9jhr 가 된다.

#### 방안 4 : 쿼드트리 (Quadtree)
　2차원 공간을 재귀적으로 분할하는 방식이다. 격자의 내용이 특정 기준(ex. 격자에 담긴 사업장 수가 100개 이하)을 만족할 떄까지 2차원 공간을 재귀적으로 사분면 분할하는데 흔히 사용되는 자료 구조이다. 
```java
// 쿼드트리 만드는 예시 코드
public void buildQuadtree(TreeNode node) {
    if (countNumberOfBusinessesInCurrentGrid(node) > 100 ) {
		node.subdivide();
		for ( TreeNode child : node.getChildren() ) {
			buildQuadtree(child);
		}
	}
}
```
　질의에 응답할 트리 구조를 메모리에 올리게 된다. 데이터베이스가 아니기 때문에 LBS 서버가 시작될때 구축해서 가지고 있어야 한다. 쿼드트리의 노드는 세계 전체지도를 나타내고 하위노드로 내려갈수록 그 양은 많아져 메모리 사용량을 검토해야 하는데 아래 수식에 의하면 문제되는 수준은 아니게 된다.
- 말단 노드 하나의 데이터
  - 격자를 식별하는 데 사용될 좌상단과 우하단 꼭짓점 좌표 (32바이트) + 격자 내부 사업장 ID 목록 (ID당 8바이트 x 100) = 합계: 832바이트
- 내부 노드에 수록되는 데이터
  - 격자를 식별하는데 사용될 좌상단과 우하단 꼭짓점 좌표 32바이트 + 하위 노드 4개를 가리킬 포인터 32 바이트 ( 8바이트 x 4 ) = 64 바이트
- 사업장의 정보는 database에 이미 레코드로 존재하기 때문에 계산에 포함하지 않는다.
- 최종 계산 : 말단 노드의 수 200만, 내부 노드의 수 67만(200만/3) * 832 바이트 =~ 1.7GB
> https://stackoverflow.com/questions/35976444/how-many-leaves-has-a-quadtree

　쿼드트리 구축에는 트리의 시간복잡도인 n log n 이 소요되므로  전체 사업장 수를 n 이라고 하고, 말단 노드에 대략 100개의 사업장이 저장된다 가정했을때 (n/100) log (n/100) 이 된다. 즉, 200백만개의 사업장 정보를 인덱싱하는 쿼드트리 구축에는 몇 분 정도 소요될 수 있지만 실제로는 단순 연산이 아니기 때문에 훨씬 더 많은 시간이 필요할 것으로 예상된다. 쿼드트리로 주변 사업장을 검색하기 위해서는 메모리에 쿼드트리 인덱스를 구축하고 검색 시작점이 포함된 말단 노드를 만날 때까지 트리의 루트 노드부터 탐색한다. 해당 노드에 100개 사업장이 있는 경우에 해당 노드만 반환하고 그렇지 않은 경우에는 충분한 사업장 수가 확보될 때까지 인접 노드도 추가하는 방식으로 처리하게 된다.

　쿼드트리 운영시에는 최초 쿼드트리 구축 시간이 걸리는 점을 고려해야 하는데 메모리에 올라가기 때문에 구축에 시간이 소요되므로 서버는 시작할때마다 수분의 서버 시작 시간이 발생한다. 이러한 이유로 동시에 너무 많은 서버개 배포되면 안되는데 서버 클러스터의 상당 부분이 동시에 꺼져서 서비스 품질이 저하될수 있고 동시에 배포 시 초기 트리 구조에 필요한 데이터를 받아오기 위해 DB 부담을 주는 상황이 발생한다. 또한 쿼드트리 갱신에 대한 고려가 되어야 하는데 점진적으로 갱신을 하는 간단한 방법을 적용해볼수 있다고 실시간 갱신도 가능하지만 설계가 많이 복잡해진다는 단점이 있다.

#### 방안 5 : 구글 S2
　구글 S2 기하(geometry) 라이브러리로 힐베르트 곡선을 이용하여 지구를 1차원 색인화 하는 방법이다. 힐베르트 곡선 상에서 인접한 두 지점은 색인화 된 1차원 공간 내에서도 인접하다는 특성이 있고 2차원 공간을 1차원 공간으로 변경하면서 공간적 접근성을 유지할 수 있다.

#### 어떤 회사가 어떤 방법을 사용하는가

| 색인 방법 | 회사 |
| --- | --- |
| Geohash | Bing, Redis, MongoDB, Lyft | 
| Quadtree | Yext |
| Geohash+Quadtree | Elasticsearch |
| S2 | Google,Tinder |

#### 지오해시 vs 쿼드트리
- 지오해시
  - 구현과 사용이 쉽고 트리 구축이 필요 없음
  - 지정 반경 내 사업장 검색 가능
  - 동적인 격자 크기 조정이 어려움
  - 색인의 갱신이 쉬움
- 쿼드트리
  - 트리를 구축해야 하므로 구현상 고려할 부분이 더 많음
  - Top k를 쉽게 구할 수 있음 (가장 가까운 주유소 검색과 같은)
  - 격자 크기를 동적으로 조정할 수 있음
  - 색인의 갱신이 까다로움
    - 사업장 정보를 삭제하기 위해 트리를 순회해야 함
    - 트리의 리밸런싱에 대한 고려 필요(애초에 크게 잡는것으로 부분 해결 가능)

---
## 3단계: 상세 설계


---
## 4단계: 마무리