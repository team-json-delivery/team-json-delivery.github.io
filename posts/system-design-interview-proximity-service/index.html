<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>주변 맛집을 찾으려면 어떻게 해야 검색이 빠를까? | Team JSON Delivery</title>
<meta name=keywords content><meta name=description content="점심을 먹기 위해 지도 앱을 켜고 적당한 위치로 화면을 이동한 뒤 &ldquo;맛집&#34;이라는 키워드로 검색을 한다. 그러면 해당 지도 범위 안에 있는 식당들이 검색되고 지도상에 마커와 함께 어디에 어떤 식당이 있는지 한눈에 볼 수 있다. 그중 괜찮은 식당을 선택하면 해당 지점(이하 사업장)의 상세 정보를 확인할 수 있고 서비스에 따라 바로 예약을 할 수 있는 기능도 제공된다. 이러한 특정 범위(위도/경도 + 반경) 내에서 키워드 검색으로 지도상에 노출을 해주는 &ldquo;근접성 서비스(proximity service)&ldquo;는 여러 서비스들에서 사용자들의 편의를 위해 다양하게 활용된다."><meta name=author content="taetaetae"><link rel=canonical href=https://team-json-delivery.github.io/posts/system-design-interview-proximity-service/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.bd435680923be95168ea1b839ff6ad8e781ccaf43d48e00fadcb1ff771ce3c90.css integrity="sha256-vUNWgJI76VFo6huDn/atjngcyvQ9SOAPrcsf93HOPJA=" rel="preload stylesheet" as=style><link rel=icon href=https://team-json-delivery.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://team-json-delivery.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://team-json-delivery.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://team-json-delivery.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://team-json-delivery.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-Y39RPCVCBC"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-Y39RPCVCBC",{anonymize_ip:!1})}</script><meta property="og:title" content="주변 맛집을 찾으려면 어떻게 해야 검색이 빠를까?"><meta property="og:description" content="점심을 먹기 위해 지도 앱을 켜고 적당한 위치로 화면을 이동한 뒤 &ldquo;맛집&#34;이라는 키워드로 검색을 한다. 그러면 해당 지도 범위 안에 있는 식당들이 검색되고 지도상에 마커와 함께 어디에 어떤 식당이 있는지 한눈에 볼 수 있다. 그중 괜찮은 식당을 선택하면 해당 지점(이하 사업장)의 상세 정보를 확인할 수 있고 서비스에 따라 바로 예약을 할 수 있는 기능도 제공된다. 이러한 특정 범위(위도/경도 + 반경) 내에서 키워드 검색으로 지도상에 노출을 해주는 &ldquo;근접성 서비스(proximity service)&ldquo;는 여러 서비스들에서 사용자들의 편의를 위해 다양하게 활용된다."><meta property="og:type" content="article"><meta property="og:url" content="https://team-json-delivery.github.io/posts/system-design-interview-proximity-service/"><meta property="og:image" content="https://team-json-delivery.github.io/images/system-design-interview-proximity-service/cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-02-06T06:27:22+09:00"><meta property="article:modified_time" content="2024-02-06T06:27:22+09:00"><meta property="og:site_name" content="Team JSON Delivery"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://team-json-delivery.github.io/images/system-design-interview-proximity-service/cover.png"><meta name=twitter:title content="주변 맛집을 찾으려면 어떻게 해야 검색이 빠를까?"><meta name=twitter:description content="점심을 먹기 위해 지도 앱을 켜고 적당한 위치로 화면을 이동한 뒤 &ldquo;맛집&#34;이라는 키워드로 검색을 한다. 그러면 해당 지도 범위 안에 있는 식당들이 검색되고 지도상에 마커와 함께 어디에 어떤 식당이 있는지 한눈에 볼 수 있다. 그중 괜찮은 식당을 선택하면 해당 지점(이하 사업장)의 상세 정보를 확인할 수 있고 서비스에 따라 바로 예약을 할 수 있는 기능도 제공된다. 이러한 특정 범위(위도/경도 + 반경) 내에서 키워드 검색으로 지도상에 노출을 해주는 &ldquo;근접성 서비스(proximity service)&ldquo;는 여러 서비스들에서 사용자들의 편의를 위해 다양하게 활용된다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://team-json-delivery.github.io/posts/"},{"@type":"ListItem","position":2,"name":"주변 맛집을 찾으려면 어떻게 해야 검색이 빠를까?","item":"https://team-json-delivery.github.io/posts/system-design-interview-proximity-service/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"주변 맛집을 찾으려면 어떻게 해야 검색이 빠를까?","name":"주변 맛집을 찾으려면 어떻게 해야 검색이 빠를까?","description":"점심을 먹기 위해 지도 앱을 켜고 적당한 위치로 화면을 이동한 뒤 \u0026ldquo;맛집\u0026quot;이라는 키워드로 검색을 한다. 그러면 해당 지도 범위 안에 있는 식당들이 검색되고 지도상에 마커와 함께 어디에 어떤 식당이 있는지 한눈에 볼 수 있다. 그중 괜찮은 식당을 선택하면 해당 지점(이하 사업장)의 상세 정보를 확인할 수 있고 서비스에 따라 바로 예약을 할 수 있는 기능도 제공된다. 이러한 특정 범위(위도/경도 + 반경) 내에서 키워드 검색으로 지도상에 노출을 해주는 \u0026ldquo;근접성 서비스(proximity service)\u0026ldquo;는 여러 서비스들에서 사용자들의 편의를 위해 다양하게 활용된다.","keywords":[],"articleBody":"　점심을 먹기 위해 지도 앱을 켜고 적당한 위치로 화면을 이동한 뒤 “맛집\"이라는 키워드로 검색을 한다. 그러면 해당 지도 범위 안에 있는 식당들이 검색되고 지도상에 마커와 함께 어디에 어떤 식당이 있는지 한눈에 볼 수 있다. 그중 괜찮은 식당을 선택하면 해당 지점(이하 사업장)의 상세 정보를 확인할 수 있고 서비스에 따라 바로 예약을 할 수 있는 기능도 제공된다. 이러한 특정 범위(위도/경도 + 반경) 내에서 키워드 검색으로 지도상에 노출을 해주는 “근접성 서비스(proximity service)“는 여러 서비스들에서 사용자들의 편의를 위해 다양하게 활용된다. 잠깐! 그런데 이러한 서비스를 만들기 위해서는 어떤 고민들이 되어야 할까?\n또 나온다고..? 알렉스 성님 숨좀 쉽시다..출처 : 도서출판 인사이트\n이번 글에서는 가상 면접 사례로 배우는 대규모 시스템 설계 기초 2의 “1장 근접성 서비스\"라는 주제로 스터디를 하고 정리해 보고자 한다. 위경도 기반의 검색이 어떻게 이루어지고 어떤 측면을 고민하고 설계를 해야 하는지에 대한 내용이다. 물론, 국내를 비롯한 해외 지도 서비스들이 이 글에서 이야기하고 있는 방식을 그대로 차용하진 않았을 테고 또한 각 서비스마다(공개하기 어려운) 약간의 차이점이 있을 수도 있겠지만 이렇게 상상을 해보는 과정에서 여러 가지를 배울 수 있을 거라 기대해 본다.\n데이터 모델 설계를 할 때는 먼저 서비스의 형태를 면밀히 파악해야 한다. 그렇지 않으면 잘못된 설계가 되거나 오버 엔지니어링 되기 쉽다. 이 서비스에서는 읽기 연산이 굉장히 자주 수행된다. 주변 사업장을 검색한다거나 사업장의 정보를 확인하는 형태가 많기 때문이다. 반대로 사업장의 정보를 등록하거나 수정/삭제하는 쓰기 연산은 상대적으로 실행 빈도가 낮다. 서비스의 특징을 미루어 봤을 때 읽기 연산이 압도적으로 많기 때문에 책에서는 MySQL 같은 관계형 데이터베이스가 바람직하다고 이야기를 하고 있지만 스터디를 진행하면서 의구심이 들었다. 일반적으로 다른 문서들을 찾아봐도 NoSQL이 읽기 처리에 강점이 있다고 나와있는데 아마도 저자는 샤딩이나 Read Replica를 활용하여 읽기의 수평 확장성을 높이는데 의미 부여하고자 빌드업 하는 건 아닐까 생각을 해봤다. 아래에 SQL vs NoSQL에 대한 아티클을 첨부해두었으니 읽어봐도 좋을 것 같다.\nhttps://velog.io/@park2348190/논문번역-SQL-vs-NoSQL-A-Performance-Comparison https://stackoverflow.com/questions/9702643/mysql-vs-mongodb-1000-reads 그리고 사업장 상세 정보와 지리적 위치가 색인되는 테이블이 필요할 것으로 보인다.\n개략적인 설계 앞단에 로드밸런서를 위치하여 검색(읽기)과 사업장(쓰기) 트래픽을 구분하여 분산 및 관리할 수 있다. 크게 두 가지 서비스로 구분해서 생각해 보자. 먼저 사업장의 정보를 관리하는 사업장 서비스는 쓰기 요청이 있긴 하지만 앞서 이야기 한 것처럼 QPS가 그렇게 높지 않다. 반면 고객이 사업장을 조회하는 특정 시간대에는 간혹 읽기 요청 QPS가 높아지지만 데이터의 변화가 많지 않기에 적당한 주기로 캐시를 설정하거나 적절하게 주-부 (primary-secondary) 데이터베이스 형태로 구성하면 트래픽 문제를 해결할 수 있다. 이처럼 Replica 형태로 구성 시엔 데이터 복제 시 지연(delay)을 고민해야 하지만 문제 되는 수준은 아니다. 위치 기반 서비스(location-based service, LBS)는 쓰기 요청은 없고 읽기 요청만 있다. QPS 가 높고 특히 특정 시간대의 인구 밀집 지역일수록 심한 특징이 있다.\n규모 확장성 측면에서 두 서비스(사업장, LBS) 모두 무상태(stateless) 서비스이므로 쉽게 확장이 가능하다. 또한 클라우드 서버의 경우 여러 지역, 여러 가용성 구역 설정으로 시스템 가용성을 높일 수 있다. Auto Scaling 관점에서 볼 때 보통은 트래픽이 늘어나면 자동으로 서버 군을 확장해서 가용성을 높이지만 반대로 새벽같이 트래픽이 적을 때는 최소한의 서버 수로 단계적 축소를 통해 비용을 절약하는 측면도 고민을 해볼 수 있을 것 같다. (개발 환경의 경우 퇴근 후나 주말 때는 최소 한대씩 혹은 아예 서버를 내린다거나…)\n주변 사업장 검색 알고리즘 구현할 서비스에서 가장 중요한 위치 기반 서비스의 주변 사업장 검색 알고리즘에 대해 고민해 보자. 먼저 간단하게 2차원 검색을 아래처럼 일반적인 query로 질의를 하기엔 데이터의 양이 많아 인덱스로 처리한다 해도 효율적이지 못하다.\nSELECT business_id, latitude, longitude, FROM business WHERE (latitude between {:my_lat} - radius AND {:my_lat} + radius) AND (longitude BETWEEN {:my_long} - raduis AND {:my_long} + radius) 다음으로는 지도를 균등하게 격자로 나누어 관리를 하는 방법도 있지만 지점의 분포가 균등하지 못하여 (도심은 많고 시골은 적은) 관리에 비효율적이다. 지역에 따라 격자의 크기를 다르게 만드는 방법이 있을 수도 있지만 지점이 격자 경계선에 있을 경우 찾기가 까다로울 수 있는 단점이 있다. (인접 격자 문제) 이 책에서 이야기하는(추천하는) 가장 보편적인 방법 중에 지오해시(Geohash) 와 쿼드트리(quadtree)에 대해 알아보자.\n지오해시는 2차원의 위도/경도를 1차원의 문자열로 변환하는 형태를 의미한다. 통상적으로 base32 표현법을 사용하는데 지구 전체를 사분면으로 나누고 각 격자를 재귀적으로 나누며 반복하는 형태이다. 원하는 정밀도(precision)을 얻을 때까지 반복하고 12단계의 정밀도를 갖는데 일반적으로 4 ~ 6사이를 사용한다.\n출처 : https://en.wikipedia.org/wiki/Geohash\n구글 본사가 위치한 지역의 지오해시는 10011101001001100011111111110으로 표현하고 base32로 표현하면 “9q9hvu\"가 된다. 또한 메타 본사가 위치한 지역의 지오해시는 동일한 형태로 처리하면 10011101001001100111000111011 가 되고 이는 다시 “9q9jhr\"로 표현할 수 있게 된다. 해시값의 공통 접두어가 긴 격자들이 서로 더 가깝게 놓이도록 보장하지만 그 역은 참이 아니다. 즉, 아주 가까운 두 위치가 공통 접두어를 갖지 않는 격자 가장자리 이슈가 여기서도 발생하는데 상수 시간에 가능한 연산이라 큰 문제가 되지 않는다. 현재 cell 인근의 격자에 대한 hash 연산으로 충분하기 때문이다. 검색하는 영역 내에 표시할 사업장이 충분하지 않는 이슈도 있다. 이 경우에도 해결 방안이 있는데 그대로 노출되는 사업장만 반환하거나 hash 값의 마지막 비트를 삭제해가면서 검색 반경을 키워 검색하는 해결 방안을 생각해 볼 수 있다. ( 카카오 지도는 w3w를 사용하는 듯 했다.)\ngeo hash https://geohash.softeng.co/ base32 to binary https://www.unitconverters.net/numbers/base-32-to-binary.htm 출처 : https://developer.apple.com/documentation/gameplaykit/gkquadtree\n쿼드트리는 2차원의 공간을 재귀적으로 분할해가며 일종의 “트리\"를 미리 구성하는 방식이다. 예컨대, 격자에 담긴 사업장 수가 100이하가 될 때까지 분할하는 형태이다. 단, 다른 방식과는 달리 쿼드트리는 메모리 안에 놓이는 자료구조일 뿐 데이터베이스가 아니라는 것에 유의해야 한다. 이는 각각의 LBS 서버에 존재해야 하며 서버가 시작하는 시점에 구축이 된다. 이러한 특징 때문에 고려해야 할 사항이 여러 가지가 있다. 먼저 메모리에 들고 있다는 것은 애플리케이션이 초기 로딩 될 때 계산되어 구축이 됨을 의미하기에 생성 시간 및 용량을 잘 고려해야 한다. 또한 배포 전략 측면에서 blue-green으로 한 번에 투입 시 트래픽의 유입이 갑자기 많이 되어 큰 부하를 입을 수가 있다. 또한 쿼드트리의 추가 또는 삭제 같은 갱신이 발생할 때는 지연이나 부하를 고려해야 한다.\nS2라는 구글이 만든 기하(geometry) 라이브러리 방식을 사용하는 방안도 있다. 이는 지구를 힐베르트 곡선이라는 공간 채움 곡선을 사용하여 1차원 색인화하는 방안이라고 한다. 힐베르트 곡선 상에 인접한 두 지점은 색인화 이후 1차원 공간 내에서도 인접한 위치에 있다는 특징을 가지고 있다. 즉, 2차원 공간을 1차원 공간으로 변경하면서 공간적 접근성을 유지할 수 있다는 장점이 있다. 하지만 이해하기 좀 어려운 건 사실이다. 아래 url에서 이것저것 눌러보면 조금은 이해가 될 수도 있다.\nhttp://bit-player.org/extras/hilbert/hilbert-mapping.html 지오해시와 쿼드트리의 장단점을 정리해 보면 다음과 같다. 기술에는 정답은 없기에 요구사항에 맞게 근거 있는 선택이 돼야 할 것이다.\n지오해시 구현과 사용이 쉬움. 트리를 구축할 필요가 없음 지정 반경 이내 사업장 검색 지원 인구 밀도에 따라 동적으로 격자 크기를 조정할 수 없음 색인 갱신이 쉬움 쿼드트리 트리 구축이 필요해서 구현이 조금 어려움 k 번째로 가까운 사업장까지의 목록을 구할 수 있음 인구 밀도에 따라 격자 크기를 동적으로 조정할 수 있음 색인 갱신이 어려움 데이터베이스의 규모 확장 사용자가 늘어난다면 데이터베이스의 규모 또한 그에 따라 확장이 되어야 한다. 데이터가 많을 경우 단일 테이블로는 서비스하기에 한계가 있으므로 사업장 테이블의 경우 사업장 id 기준으로 샤딩을 통해 트래픽의 분산 효과를 볼 수 있다. 지리 정보 색인 테이블의 경우 geohash 와 사업장 id 목록을 json으로 관리하거나 geohash 와 사업장 id 별로 하나의 row로 관리하는 방식이 있는데 후자를 추천하는 이유는 업데이트 및 조회 측면에서 이득이기 때문이다.\n대용량 데이터 관리 측면에서 샤딩이 늘 좋은 선택지인건 아니다. 사본 데이터베이스를 구성하여 읽기 트래픽을 분산만 해도 해결될 수도 있고 오히려 샤딩 로직이 애플리케이션 계층에 구현해야 하기 때문에 까다로울 수 있는 단점도 존재한다.\n상세한 설계 캐시가 꼭 만병통치약은 아니다. 만약 RDMBS 상황에서 읽기 성능이 병목이라면 사본 데이터베이스를 증설하는 방법 또한 고려해 볼 사항이고 캐시를 둔다는 건 오히려 관리 포인트를 동반한 비용이 발생되는 점을 잊지 말아야 한다. 사업장 정보는 자주 변경되지 않기 때문에 Redis 같은 키 값 저장소에 캐시 할 수 있다. 고가용성을 보장하고 대륙 경계를 넘는 트래픽의 전송 지연을 방지하기 위해서는 레디스 클러스터를 전 세계에 각 지역별로 두고, 동일한 데이터를 각 지역에 중복해서 저장하고 서비스를 운영할 수 있다.\n추가질문 : 시간대, 혹은 사업장 유형별 검색 지오해시나 쿼드트리를 적용하면 사업장은 그렇게 많지 않을 것이다. 그렇기 때문에 사업장을 조회한 뒤 영업시간으로 필터링 하면 쉽게 해결이 가능 할수도 있다. 만약, 현재 영업 중인 100개의 사업장을 찾고 싶다는 요구사항이 있을 경우엔 100개에 도달할 때까지 계속 확장해 나가야 하기에 어려움이 있다. 이처럼 어떤 방식이든 페이징을 서버에 의존하는 것은 늘 어려움이 동반된다. 가령, 주변에 있는 예약 가능한 택시를 찾는 앱 같은 경우 점점 범위를 확장해 나가다 찾을 수 없으니 다시 시도해 달라는 서비스의 스펙으로 해결하는 경우도 있다.\n마치며 가볍게 생각해 볼 만했던 주제였지만 여러 가지 요구사항을 만족하기 위해서는 다양한 측면으로 고려를 해야 했고 특히 대용량 서비스를 대상으로 설계를 하다 보니 지오해시나 쿼드트리 같은 새로운 알고리즘을 활용해서 아주 효율적으로 위/경도 기반의 검색 시스템을 구성할 수 있었다. 특히 캐싱이나 샤딩같은 방식을 도입했을 때 무조건 장점만 있는 건 아니고 반대로 고려해야 할 사항들이 있다는 것, 더불어 배포 전략에 따라 서비스가 오히려 천국과 지옥을 오갈 수 있겠다는 점에서 평소 다루는 서비스에 배포 전략을 다시 한번 고민하는 계기가 되었던 것 같다.\n","wordCount":"1327","inLanguage":"en","image":"https://team-json-delivery.github.io/images/system-design-interview-proximity-service/cover.png","datePublished":"2024-02-06T06:27:22+09:00","dateModified":"2024-02-06T06:27:22+09:00","author":{"@type":"Person","name":"taetaetae"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://team-json-delivery.github.io/posts/system-design-interview-proximity-service/"},"publisher":{"@type":"Organization","name":"Team JSON Delivery","logo":{"@type":"ImageObject","url":"https://team-json-delivery.github.io/%3Clink%20/%20abs%20url%3E"}}}</script><script>function changeGiscusTheme(){const e=document.body.classList.contains("dark")?"dark":"light";function t(e){const t=document.querySelector("iframe.giscus-frame");if(!t)return;t.contentWindow.postMessage({giscus:e},"https://giscus.app")}t({setConfig:{theme:e}})}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?(document.body.classList.add("dark"),setTimeout(changeGiscusTheme,2e3)):localStorage.getItem("pref-theme")==="light"?(document.body.classList.remove("dark"),setTimeout(changeGiscusTheme,2e3)):window.matchMedia("(prefers-color-scheme: dark)").matches&&(document.body.classList.add("dark"),setTimeout(changeGiscusTheme,2e3))</script><header class=header><nav class=nav><div class=logo><a href=https://team-json-delivery.github.io/ accesskey=h title="Team JSON Delivery (Alt + H)"><img src=https://team-json-delivery.github.io/apple-touch-icon.png alt aria-label=logo height=35>Team JSON Delivery</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://team-json-delivery.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://team-json-delivery.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://team-json-delivery.github.io/author/ title=author><span>author</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://team-json-delivery.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://team-json-delivery.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent" style=word-break:keep-all>주변 맛집을 찾으려면 어떻게 해야 검색이 빠를까?</h1><div class=post-meta><span title='2024-02-06 06:27:22 +0900 +0900'>2024년 02월 06일</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1327 words&nbsp;·&nbsp;taetaetae&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/system-design-interview-proximity-service.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><div id=figmask style=z-index:-1><img loading=eager src=https://team-json-delivery.github.io/images/system-design-interview-proximity-service/cover.png alt></div></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#데이터-모델>데이터 모델</a></li><li><a href=#개략적인-설계>개략적인 설계</a></li><li><a href=#주변-사업장-검색-알고리즘>주변 사업장 검색 알고리즘</a></li><li><a href=#데이터베이스의-규모-확장>데이터베이스의 규모 확장</a></li><li><a href=#상세한-설계>상세한 설계</a></li><li><a href=#추가질문--시간대-혹은-사업장-유형별-검색>추가질문 : 시간대, 혹은 사업장 유형별 검색</a></li><li><a href=#마치며>마치며</a></li></ul></nav></div></details></div><div class=post-content><p>　점심을 먹기 위해 지도 앱을 켜고 적당한 위치로 화면을 이동한 뒤 &ldquo;맛집"이라는 키워드로 검색을 한다. 그러면 해당 지도 범위 안에 있는 식당들이 검색되고 지도상에 마커와 함께 어디에 어떤 식당이 있는지 한눈에 볼 수 있다. 그중 괜찮은 식당을 선택하면 해당 지점(이하 사업장)의 상세 정보를 확인할 수 있고 서비스에 따라 바로 예약을 할 수 있는 기능도 제공된다. 이러한 특정 범위(위도/경도 + 반경) 내에서 키워드 검색으로 지도상에 노출을 해주는 &ldquo;근접성 서비스(proximity service)&ldquo;는 여러 서비스들에서 사용자들의 편의를 위해 다양하게 활용된다. 잠깐! 그런데 이러한 서비스를 만들기 위해서는 어떤 고민들이 되어야 할까?</p><figure class=align-center><img loading=lazy src=/images/system-design-interview-proximity-service/alexxu.jpg#center width=50%><figcaption><p>또 나온다고..? 알렉스 성님 숨좀 쉽시다..출처 : 도서출판 인사이트</p></figcaption></figure><p>　이번 글에서는 <a href=https://product.kyobobook.co.kr/detail/S000211656186>가상 면접 사례로 배우는 대규모 시스템 설계 기초 2</a>의 &ldquo;1장 근접성 서비스"라는 주제로 스터디를 하고 정리해 보고자 한다. 위경도 기반의 검색이 어떻게 이루어지고 어떤 측면을 고민하고 설계를 해야 하는지에 대한 내용이다. 물론, 국내를 비롯한 해외 지도 서비스들이 이 글에서 이야기하고 있는 방식을 그대로 차용하진 않았을 테고 또한 각 서비스마다(공개하기 어려운) 약간의 차이점이 있을 수도 있겠지만 이렇게 상상을 해보는 과정에서 여러 가지를 배울 수 있을 거라 기대해 본다.</p><h2 id=데이터-모델>데이터 모델<a hidden class=anchor aria-hidden=true href=#데이터-모델>#</a></h2><p>　설계를 할 때는 먼저 서비스의 형태를 면밀히 파악해야 한다. 그렇지 않으면 잘못된 설계가 되거나 오버 엔지니어링 되기 쉽다. 이 서비스에서는 읽기 연산이 굉장히 자주 수행된다. 주변 사업장을 검색한다거나 사업장의 정보를 확인하는 형태가 많기 때문이다. 반대로 사업장의 정보를 등록하거나 수정/삭제하는 쓰기 연산은 상대적으로 실행 빈도가 낮다. 서비스의 특징을 미루어 봤을 때 읽기 연산이 압도적으로 많기 때문에 책에서는 MySQL 같은 관계형 데이터베이스가 바람직하다고 이야기를 하고 있지만 스터디를 진행하면서 의구심이 들었다. 일반적으로 다른 문서들을 찾아봐도 NoSQL이 읽기 처리에 강점이 있다고 나와있는데 아마도 저자는 샤딩이나 Read Replica를 활용하여 읽기의 수평 확장성을 높이는데 의미 부여하고자 빌드업 하는 건 아닐까 생각을 해봤다. 아래에 SQL vs NoSQL에 대한 아티클을 첨부해두었으니 읽어봐도 좋을 것 같다.</p><ul><li><a href=https://velog.io/@park2348190/%EB%85%BC%EB%AC%B8%EB%B2%88%EC%97%AD-SQL-vs-NoSQL-A-Performance-Comparison>https://velog.io/@park2348190/논문번역-SQL-vs-NoSQL-A-Performance-Comparison</a></li><li><a href=https://stackoverflow.com/questions/9702643/mysql-vs-mongodb-1000-reads>https://stackoverflow.com/questions/9702643/mysql-vs-mongodb-1000-reads</a></li></ul><p>그리고 사업장 상세 정보와 지리적 위치가 색인되는 테이블이 필요할 것으로 보인다.</p><h2 id=개략적인-설계>개략적인 설계<a hidden class=anchor aria-hidden=true href=#개략적인-설계>#</a></h2><p>　앞단에 로드밸런서를 위치하여 검색(읽기)과 사업장(쓰기) 트래픽을 구분하여 분산 및 관리할 수 있다. 크게 두 가지 서비스로 구분해서 생각해 보자. 먼저 사업장의 정보를 관리하는 사업장 서비스는 쓰기 요청이 있긴 하지만 앞서 이야기 한 것처럼 QPS가 그렇게 높지 않다. 반면 고객이 사업장을 조회하는 특정 시간대에는 간혹 읽기 요청 QPS가 높아지지만 데이터의 변화가 많지 않기에 적당한 주기로 캐시를 설정하거나 적절하게 주-부 (primary-secondary) 데이터베이스 형태로 구성하면 트래픽 문제를 해결할 수 있다. 이처럼 Replica 형태로 구성 시엔 데이터 복제 시 지연(delay)을 고민해야 하지만 문제 되는 수준은 아니다. 위치 기반 서비스(location-based service, LBS)는 쓰기 요청은 없고 읽기 요청만 있다. QPS 가 높고 특히 특정 시간대의 인구 밀집 지역일수록 심한 특징이 있다.</p><p>　규모 확장성 측면에서 두 서비스(사업장, LBS) 모두 무상태(stateless) 서비스이므로 쉽게 확장이 가능하다. 또한 클라우드 서버의 경우 여러 지역, 여러 가용성 구역 설정으로 시스템 가용성을 높일 수 있다. Auto Scaling 관점에서 볼 때 보통은 트래픽이 늘어나면 자동으로 서버 군을 확장해서 가용성을 높이지만 반대로 새벽같이 트래픽이 적을 때는 최소한의 서버 수로 단계적 축소를 통해 비용을 절약하는 측면도 고민을 해볼 수 있을 것 같다. (개발 환경의 경우 퇴근 후나 주말 때는 최소 한대씩 혹은 아예 서버를 내린다거나&mldr;)</p><h2 id=주변-사업장-검색-알고리즘>주변 사업장 검색 알고리즘<a hidden class=anchor aria-hidden=true href=#주변-사업장-검색-알고리즘>#</a></h2><p>　구현할 서비스에서 가장 중요한 위치 기반 서비스의 주변 사업장 검색 알고리즘에 대해 고민해 보자. 먼저 간단하게 2차원 검색을 아래처럼 일반적인 query로 질의를 하기엔 데이터의 양이 많아 인덱스로 처리한다 해도 효율적이지 못하다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>business_id</span><span class=p>,</span><span class=w> </span><span class=n>latitude</span><span class=p>,</span><span class=w> </span><span class=n>longitude</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FROM</span><span class=w> </span><span class=n>business</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>WHERE</span><span class=w> </span><span class=p>(</span><span class=n>latitude</span><span class=w> </span><span class=k>between</span><span class=w> </span><span class=err>{</span><span class=p>:</span><span class=n>my_lat</span><span class=err>}</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>radius</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=err>{</span><span class=p>:</span><span class=n>my_lat</span><span class=err>}</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>radius</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>AND</span><span class=w> </span><span class=p>(</span><span class=n>longitude</span><span class=w> </span><span class=k>BETWEEN</span><span class=w> </span><span class=err>{</span><span class=p>:</span><span class=n>my_long</span><span class=err>}</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>raduis</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=err>{</span><span class=p>:</span><span class=n>my_long</span><span class=err>}</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>radius</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></div><p>　다음으로는 지도를 균등하게 격자로 나누어 관리를 하는 방법도 있지만 지점의 분포가 균등하지 못하여 (도심은 많고 시골은 적은) 관리에 비효율적이다. 지역에 따라 격자의 크기를 다르게 만드는 방법이 있을 수도 있지만 지점이 격자 경계선에 있을 경우 찾기가 까다로울 수 있는 단점이 있다. (인접 격자 문제) 이 책에서 이야기하는(추천하는) 가장 보편적인 방법 중에 지오해시(Geohash) 와 쿼드트리(quadtree)에 대해 알아보자.</p><p>　지오해시는 2차원의 위도/경도를 1차원의 문자열로 변환하는 형태를 의미한다. 통상적으로 base32 표현법을 사용하는데 지구 전체를 사분면으로 나누고 각 격자를 재귀적으로 나누며 반복하는 형태이다. 원하는 정밀도(precision)을 얻을 때까지 반복하고 12단계의 정밀도를 갖는데 일반적으로 4 ~ 6사이를 사용한다.</p><figure class=align-center><img loading=lazy src=/images/system-design-interview-proximity-service/Geohash-grid.png#center width=80%><figcaption><p>출처 : <a href=https://en.wikipedia.org/wiki/Geohash>https://en.wikipedia.org/wiki/Geohash</a></p></figcaption></figure><p>　구글 본사가 위치한 지역의 지오해시는 10011101001001100011111111110으로 표현하고 base32로 표현하면 &ldquo;9q9hvu"가 된다. 또한 메타 본사가 위치한 지역의 지오해시는 동일한 형태로 처리하면 10011101001001100111000111011 가 되고 이는 다시 &ldquo;9q9jhr"로 표현할 수 있게 된다. 해시값의 공통 접두어가 긴 격자들이 서로 더 가깝게 놓이도록 보장하지만 그 역은 참이 아니다. 즉, 아주 가까운 두 위치가 공통 접두어를 갖지 않는 격자 가장자리 이슈가 여기서도 발생하는데 상수 시간에 가능한 연산이라 큰 문제가 되지 않는다. 현재 cell 인근의 격자에 대한 hash 연산으로 충분하기 때문이다. 검색하는 영역 내에 표시할 사업장이 충분하지 않는 이슈도 있다. 이 경우에도 해결 방안이 있는데 그대로 노출되는 사업장만 반환하거나 hash 값의 마지막 비트를 삭제해가면서 검색 반경을 키워 검색하는 해결 방안을 생각해 볼 수 있다. ( 카카오 지도는 <a href=https://what3words.com/>w3w</a>를 사용하는 듯 했다.)</p><ul><li>geo hash <a href=https://geohash.softeng.co/>https://geohash.softeng.co/</a></li><li>base32 to binary <a href=https://www.unitconverters.net/numbers/base-32-to-binary.htm>https://www.unitconverters.net/numbers/base-32-to-binary.htm</a></li></ul><figure class=align-center><img loading=lazy src=/images/system-design-interview-proximity-service/quadtree.png#center width=80%><figcaption><p>출처 : <a href=https://developer.apple.com/documentation/gameplaykit/gkquadtree>https://developer.apple.com/documentation/gameplaykit/gkquadtree</a></p></figcaption></figure><p>　쿼드트리는 2차원의 공간을 재귀적으로 분할해가며 일종의 &ldquo;트리"를 미리 구성하는 방식이다. 예컨대, 격자에 담긴 사업장 수가 100이하가 될 때까지 분할하는 형태이다. 단, 다른 방식과는 달리 쿼드트리는 메모리 안에 놓이는 자료구조일 뿐 데이터베이스가 아니라는 것에 유의해야 한다. 이는 각각의 LBS 서버에 존재해야 하며 서버가 시작하는 시점에 구축이 된다. 이러한 특징 때문에 고려해야 할 사항이 여러 가지가 있다. 먼저 메모리에 들고 있다는 것은 애플리케이션이 초기 로딩 될 때 계산되어 구축이 됨을 의미하기에 생성 시간 및 용량을 잘 고려해야 한다. 또한 배포 전략 측면에서 blue-green으로 한 번에 투입 시 트래픽의 유입이 갑자기 많이 되어 큰 부하를 입을 수가 있다. 또한 쿼드트리의 추가 또는 삭제 같은 갱신이 발생할 때는 지연이나 부하를 고려해야 한다.</p><p>　S2라는 구글이 만든 기하(geometry) 라이브러리 방식을 사용하는 방안도 있다. 이는 지구를 힐베르트 곡선이라는 공간 채움 곡선을 사용하여 1차원 색인화하는 방안이라고 한다. 힐베르트 곡선 상에 인접한 두 지점은 색인화 이후 1차원 공간 내에서도 인접한 위치에 있다는 특징을 가지고 있다. 즉, 2차원 공간을 1차원 공간으로 변경하면서 공간적 접근성을 유지할 수 있다는 장점이 있다. 하지만 이해하기 좀 어려운 건 사실이다. 아래 url에서 이것저것 눌러보면 조금은 이해가 될 수도 있다.</p><ul><li><a href=http://bit-player.org/extras/hilbert/hilbert-mapping.html>http://bit-player.org/extras/hilbert/hilbert-mapping.html</a></li></ul><p>　지오해시와 쿼드트리의 장단점을 정리해 보면 다음과 같다. 기술에는 정답은 없기에 요구사항에 맞게 근거 있는 선택이 돼야 할 것이다.</p><ul><li>지오해시<ul><li>구현과 사용이 쉬움. 트리를 구축할 필요가 없음</li><li>지정 반경 이내 사업장 검색 지원</li><li>인구 밀도에 따라 동적으로 격자 크기를 조정할 수 없음</li><li>색인 갱신이 쉬움</li></ul></li><li>쿼드트리<ul><li>트리 구축이 필요해서 구현이 조금 어려움</li><li>k 번째로 가까운 사업장까지의 목록을 구할 수 있음</li><li>인구 밀도에 따라 격자 크기를 동적으로 조정할 수 있음</li><li>색인 갱신이 어려움</li></ul></li></ul><h2 id=데이터베이스의-규모-확장>데이터베이스의 규모 확장<a hidden class=anchor aria-hidden=true href=#데이터베이스의-규모-확장>#</a></h2><p>　사용자가 늘어난다면 데이터베이스의 규모 또한 그에 따라 확장이 되어야 한다. 데이터가 많을 경우 단일 테이블로는 서비스하기에 한계가 있으므로 사업장 테이블의 경우 사업장 id 기준으로 샤딩을 통해 트래픽의 분산 효과를 볼 수 있다. 지리 정보 색인 테이블의 경우 geohash 와 사업장 id 목록을 json으로 관리하거나 geohash 와 사업장 id 별로 하나의 row로 관리하는 방식이 있는데 후자를 추천하는 이유는 업데이트 및 조회 측면에서 이득이기 때문이다.</p><p>　대용량 데이터 관리 측면에서 샤딩이 늘 좋은 선택지인건 아니다. 사본 데이터베이스를 구성하여 읽기 트래픽을 분산만 해도 해결될 수도 있고 오히려 샤딩 로직이 애플리케이션 계층에 구현해야 하기 때문에 까다로울 수 있는 단점도 존재한다.</p><h2 id=상세한-설계>상세한 설계<a hidden class=anchor aria-hidden=true href=#상세한-설계>#</a></h2><p>　캐시가 꼭 만병통치약은 아니다. 만약 RDMBS 상황에서 읽기 성능이 병목이라면 사본 데이터베이스를 증설하는 방법 또한 고려해 볼 사항이고 캐시를 둔다는 건 오히려 관리 포인트를 동반한 비용이 발생되는 점을 잊지 말아야 한다. 사업장 정보는 자주 변경되지 않기 때문에 Redis 같은 키 값 저장소에 캐시 할 수 있다. 고가용성을 보장하고 대륙 경계를 넘는 트래픽의 전송 지연을 방지하기 위해서는 레디스 클러스터를 전 세계에 각 지역별로 두고, 동일한 데이터를 각 지역에 중복해서 저장하고 서비스를 운영할 수 있다.</p><h2 id=추가질문--시간대-혹은-사업장-유형별-검색>추가질문 : 시간대, 혹은 사업장 유형별 검색<a hidden class=anchor aria-hidden=true href=#추가질문--시간대-혹은-사업장-유형별-검색>#</a></h2><p>　지오해시나 쿼드트리를 적용하면 사업장은 그렇게 많지 않을 것이다. 그렇기 때문에 사업장을 조회한 뒤 영업시간으로 필터링 하면 쉽게 해결이 가능 할수도 있다. 만약, 현재 영업 중인 100개의 사업장을 찾고 싶다는 요구사항이 있을 경우엔 100개에 도달할 때까지 계속 확장해 나가야 하기에 어려움이 있다. 이처럼 어떤 방식이든 페이징을 서버에 의존하는 것은 늘 어려움이 동반된다. 가령, 주변에 있는 예약 가능한 택시를 찾는 앱 같은 경우 점점 범위를 확장해 나가다 찾을 수 없으니 다시 시도해 달라는 서비스의 스펙으로 해결하는 경우도 있다.</p><h2 id=마치며>마치며<a hidden class=anchor aria-hidden=true href=#마치며>#</a></h2><p>　가볍게 생각해 볼 만했던 주제였지만 여러 가지 요구사항을 만족하기 위해서는 다양한 측면으로 고려를 해야 했고 특히 대용량 서비스를 대상으로 설계를 하다 보니 지오해시나 쿼드트리 같은 새로운 알고리즘을 활용해서 아주 효율적으로 위/경도 기반의 검색 시스템을 구성할 수 있었다. 특히 캐싱이나 샤딩같은 방식을 도입했을 때 무조건 장점만 있는 건 아니고 반대로 고려해야 할 사항들이 있다는 것, 더불어 배포 전략에 따라 서비스가 오히려 천국과 지옥을 오갈 수 있겠다는 점에서 평소 다루는 서비스에 배포 전략을 다시 한번 고민하는 계기가 되었던 것 같다.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://team-json-delivery.github.io/posts/nearby-service/><span class=title>« Prev</span><br><span>내 근처에는 누가 살고 있을까? : 위치 기반 서비스 설계하기</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 주변 맛집을 찾으려면 어떻게 해야 검색이 빠를까? on x" href="https://x.com/intent/tweet/?text=%ec%a3%bc%eb%b3%80%20%eb%a7%9b%ec%a7%91%ec%9d%84%20%ec%b0%be%ec%9c%bc%eb%a0%a4%eb%a9%b4%20%ec%96%b4%eb%96%bb%ea%b2%8c%20%ed%95%b4%ec%95%bc%20%ea%b2%80%ec%83%89%ec%9d%b4%20%eb%b9%a0%eb%a5%bc%ea%b9%8c%3f&amp;url=https%3a%2f%2fteam-json-delivery.github.io%2fposts%2fsystem-design-interview-proximity-service%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 주변 맛집을 찾으려면 어떻게 해야 검색이 빠를까? on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fteam-json-delivery.github.io%2fposts%2fsystem-design-interview-proximity-service%2f&amp;title=%ec%a3%bc%eb%b3%80%20%eb%a7%9b%ec%a7%91%ec%9d%84%20%ec%b0%be%ec%9c%bc%eb%a0%a4%eb%a9%b4%20%ec%96%b4%eb%96%bb%ea%b2%8c%20%ed%95%b4%ec%95%bc%20%ea%b2%80%ec%83%89%ec%9d%b4%20%eb%b9%a0%eb%a5%bc%ea%b9%8c%3f&amp;summary=%ec%a3%bc%eb%b3%80%20%eb%a7%9b%ec%a7%91%ec%9d%84%20%ec%b0%be%ec%9c%bc%eb%a0%a4%eb%a9%b4%20%ec%96%b4%eb%96%bb%ea%b2%8c%20%ed%95%b4%ec%95%bc%20%ea%b2%80%ec%83%89%ec%9d%b4%20%eb%b9%a0%eb%a5%bc%ea%b9%8c%3f&amp;source=https%3a%2f%2fteam-json-delivery.github.io%2fposts%2fsystem-design-interview-proximity-service%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 주변 맛집을 찾으려면 어떻게 해야 검색이 빠를까? on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fteam-json-delivery.github.io%2fposts%2fsystem-design-interview-proximity-service%2f&title=%ec%a3%bc%eb%b3%80%20%eb%a7%9b%ec%a7%91%ec%9d%84%20%ec%b0%be%ec%9c%bc%eb%a0%a4%eb%a9%b4%20%ec%96%b4%eb%96%bb%ea%b2%8c%20%ed%95%b4%ec%95%bc%20%ea%b2%80%ec%83%89%ec%9d%b4%20%eb%b9%a0%eb%a5%bc%ea%b9%8c%3f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 주변 맛집을 찾으려면 어떻게 해야 검색이 빠를까? on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fteam-json-delivery.github.io%2fposts%2fsystem-design-interview-proximity-service%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 주변 맛집을 찾으려면 어떻게 해야 검색이 빠를까? on whatsapp" href="https://api.whatsapp.com/send?text=%ec%a3%bc%eb%b3%80%20%eb%a7%9b%ec%a7%91%ec%9d%84%20%ec%b0%be%ec%9c%bc%eb%a0%a4%eb%a9%b4%20%ec%96%b4%eb%96%bb%ea%b2%8c%20%ed%95%b4%ec%95%bc%20%ea%b2%80%ec%83%89%ec%9d%b4%20%eb%b9%a0%eb%a5%bc%ea%b9%8c%3f%20-%20https%3a%2f%2fteam-json-delivery.github.io%2fposts%2fsystem-design-interview-proximity-service%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 주변 맛집을 찾으려면 어떻게 해야 검색이 빠를까? on telegram" href="https://telegram.me/share/url?text=%ec%a3%bc%eb%b3%80%20%eb%a7%9b%ec%a7%91%ec%9d%84%20%ec%b0%be%ec%9c%bc%eb%a0%a4%eb%a9%b4%20%ec%96%b4%eb%96%bb%ea%b2%8c%20%ed%95%b4%ec%95%bc%20%ea%b2%80%ec%83%89%ec%9d%b4%20%eb%b9%a0%eb%a5%bc%ea%b9%8c%3f&amp;url=https%3a%2f%2fteam-json-delivery.github.io%2fposts%2fsystem-design-interview-proximity-service%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 주변 맛집을 찾으려면 어떻게 해야 검색이 빠를까? on ycombinator" href="https://news.ycombinator.com/submitlink?t=%ec%a3%bc%eb%b3%80%20%eb%a7%9b%ec%a7%91%ec%9d%84%20%ec%b0%be%ec%9c%bc%eb%a0%a4%eb%a9%b4%20%ec%96%b4%eb%96%bb%ea%b2%8c%20%ed%95%b4%ec%95%bc%20%ea%b2%80%ec%83%89%ec%9d%b4%20%eb%b9%a0%eb%a5%bc%ea%b9%8c%3f&u=https%3a%2f%2fteam-json-delivery.github.io%2fposts%2fsystem-design-interview-proximity-service%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://giscus.app/client.js data-repo=team-json-delivery/team-json-delivery.github.io data-repo-id=R_kgDOLAMZNQ data-category=comment data-category-id=DIC_kwDOLAMZNc4CcJ4o data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=ko crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://team-json-delivery.github.io/>Team JSON Delivery</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light"),changeGiscusTheme()):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"),changeGiscusTheme())})</script></body></html>