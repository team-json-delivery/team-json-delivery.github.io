<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>주변 맛집을 찾으려면 어떻게 해야 검색이 빠를까? | Team JSON Delivery</title>
<meta name=keywords content><meta name=description content="맛집을 찾으려 포털사이트에서 키워드로 검색하는 경우가 있다. &ldquo;중식 맛집&rdquo; 또는 &ldquo;분위기 좋은 카페&rdquo; 같은 특정 키워드로 검색을 하게 되면 블로그 후기를 본다거나 지도 서비스를 활용하여 어디에 있는지 위치를 확인한다. 블로그 후기의 경우 수많은 웹문서들을 검색 엔진이 미리 색인을 해두고 검색 키워드에 따라 결과를 보여주는 형태라고 가볍게 추측해볼수 있을것 같은데 지도상에 어디에 지점이 있는지 알려주는 지도 서비스에서는 어떻게 위치 기반으로 검색을 할 수 있을까? 단순히 위경도 기준으로 쿼리 돌려 조회하면 되겠지 싶다가도 국내를 넘어 글로벌 지도 서비스까지 생각해보면 그 양이 어마어마 할텐데 1초 이내로 검색이 빠르게 되는걸 보면 그저 대단하다 라고 생각하기엔 내부 구현이 궁금해진다."><meta name=author content="taetaetae"><link rel=canonical href=https://team-json-delivery.github.io/posts/system-design-interview-proximity-service/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.bd435680923be95168ea1b839ff6ad8e781ccaf43d48e00fadcb1ff771ce3c90.css integrity="sha256-vUNWgJI76VFo6huDn/atjngcyvQ9SOAPrcsf93HOPJA=" rel="preload stylesheet" as=style><link rel=icon href=https://team-json-delivery.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://team-json-delivery.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://team-json-delivery.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://team-json-delivery.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://team-json-delivery.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-Y39RPCVCBC"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-Y39RPCVCBC",{anonymize_ip:!1})}</script><meta property="og:title" content="주변 맛집을 찾으려면 어떻게 해야 검색이 빠를까?"><meta property="og:description" content="맛집을 찾으려 포털사이트에서 키워드로 검색하는 경우가 있다. &ldquo;중식 맛집&rdquo; 또는 &ldquo;분위기 좋은 카페&rdquo; 같은 특정 키워드로 검색을 하게 되면 블로그 후기를 본다거나 지도 서비스를 활용하여 어디에 있는지 위치를 확인한다. 블로그 후기의 경우 수많은 웹문서들을 검색 엔진이 미리 색인을 해두고 검색 키워드에 따라 결과를 보여주는 형태라고 가볍게 추측해볼수 있을것 같은데 지도상에 어디에 지점이 있는지 알려주는 지도 서비스에서는 어떻게 위치 기반으로 검색을 할 수 있을까? 단순히 위경도 기준으로 쿼리 돌려 조회하면 되겠지 싶다가도 국내를 넘어 글로벌 지도 서비스까지 생각해보면 그 양이 어마어마 할텐데 1초 이내로 검색이 빠르게 되는걸 보면 그저 대단하다 라고 생각하기엔 내부 구현이 궁금해진다."><meta property="og:type" content="article"><meta property="og:url" content="https://team-json-delivery.github.io/posts/system-design-interview-proximity-service/"><meta property="og:image" content="https://team-json-delivery.github.io/images/system-design-interview-proximity-service/cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-01-11T06:27:22+09:00"><meta property="article:modified_time" content="2024-01-11T06:27:22+09:00"><meta property="og:site_name" content="Team JSON Delivery"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://team-json-delivery.github.io/images/system-design-interview-proximity-service/cover.png"><meta name=twitter:title content="주변 맛집을 찾으려면 어떻게 해야 검색이 빠를까?"><meta name=twitter:description content="맛집을 찾으려 포털사이트에서 키워드로 검색하는 경우가 있다. &ldquo;중식 맛집&rdquo; 또는 &ldquo;분위기 좋은 카페&rdquo; 같은 특정 키워드로 검색을 하게 되면 블로그 후기를 본다거나 지도 서비스를 활용하여 어디에 있는지 위치를 확인한다. 블로그 후기의 경우 수많은 웹문서들을 검색 엔진이 미리 색인을 해두고 검색 키워드에 따라 결과를 보여주는 형태라고 가볍게 추측해볼수 있을것 같은데 지도상에 어디에 지점이 있는지 알려주는 지도 서비스에서는 어떻게 위치 기반으로 검색을 할 수 있을까? 단순히 위경도 기준으로 쿼리 돌려 조회하면 되겠지 싶다가도 국내를 넘어 글로벌 지도 서비스까지 생각해보면 그 양이 어마어마 할텐데 1초 이내로 검색이 빠르게 되는걸 보면 그저 대단하다 라고 생각하기엔 내부 구현이 궁금해진다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://team-json-delivery.github.io/posts/"},{"@type":"ListItem","position":2,"name":"주변 맛집을 찾으려면 어떻게 해야 검색이 빠를까?","item":"https://team-json-delivery.github.io/posts/system-design-interview-proximity-service/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"주변 맛집을 찾으려면 어떻게 해야 검색이 빠를까?","name":"주변 맛집을 찾으려면 어떻게 해야 검색이 빠를까?","description":"맛집을 찾으려 포털사이트에서 키워드로 검색하는 경우가 있다. \u0026ldquo;중식 맛집\u0026rdquo; 또는 \u0026ldquo;분위기 좋은 카페\u0026rdquo; 같은 특정 키워드로 검색을 하게 되면 블로그 후기를 본다거나 지도 서비스를 활용하여 어디에 있는지 위치를 확인한다. 블로그 후기의 경우 수많은 웹문서들을 검색 엔진이 미리 색인을 해두고 검색 키워드에 따라 결과를 보여주는 형태라고 가볍게 추측해볼수 있을것 같은데 지도상에 어디에 지점이 있는지 알려주는 지도 서비스에서는 어떻게 위치 기반으로 검색을 할 수 있을까? 단순히 위경도 기준으로 쿼리 돌려 조회하면 되겠지 싶다가도 국내를 넘어 글로벌 지도 서비스까지 생각해보면 그 양이 어마어마 할텐데 1초 이내로 검색이 빠르게 되는걸 보면 그저 대단하다 라고 생각하기엔 내부 구현이 궁금해진다.","keywords":[],"articleBody":"　맛집을 찾으려 포털사이트에서 키워드로 검색하는 경우가 있다. “중식 맛집” 또는 “분위기 좋은 카페” 같은 특정 키워드로 검색을 하게 되면 블로그 후기를 본다거나 지도 서비스를 활용하여 어디에 있는지 위치를 확인한다. 블로그 후기의 경우 수많은 웹문서들을 검색 엔진이 미리 색인을 해두고 검색 키워드에 따라 결과를 보여주는 형태라고 가볍게 추측해볼수 있을것 같은데 지도상에 어디에 지점이 있는지 알려주는 지도 서비스에서는 어떻게 위치 기반으로 검색을 할 수 있을까? 단순히 위경도 기준으로 쿼리 돌려 조회하면 되겠지 싶다가도 국내를 넘어 글로벌 지도 서비스까지 생각해보면 그 양이 어마어마 할텐데 1초 이내로 검색이 빠르게 되는걸 보면 그저 대단하다 라고 생각하기엔 내부 구현이 궁금해진다.\n이번 글에서는 가상 면접 사례로 배우는 대규모 시스템 설계 기초 2의 “1장 근접성 서비스\"라는 주제를 스터디하고 정리해보고자 한다. 위경도 좌표 기반의 검색이 어떻게 이루어 지고 어떤 측면을 고민하고 설계를 해야 하는지에 대한 내용이다. 물론, 국내를 비롯한 해외 지도 서비스들이 이 글에서 이야기 하고 있는 방식을 그대로 차용하진 않았을테고 또한 각 서비스마다(공개하기 어려운) 약간의 차이점이 있을수도 있겠지만 이렇게 상상을 해보는 과정에서 여러가지를 배울수 있을꺼라 기대해 본다.\n1단계 : 문제 이해 및 설계 범위 확정 설계를 잘하기 위해서는 구현해야할 상황을 잘 파악하고 범위를 좁히는 것이 선행되어야 한다. 그렇지 않으면 오버 엔지니어링이 되거나 구현해야할 핵심과 가치에 벗어나는 설계가 될 수 있다. 크게 “기능 요구사항\"과 “비기능 요구사항\"으로 구분지어 범위를 정리해볼수 있다.\n기능 요구사항 사용자의 위치(위/경도)와 검색 반경 정보에 매치되는 사업장(지점)을 조회되어야 하고 사업장 소유주는 사업장의 정보를 추가, 수정, 삭제를 할 수 있어야 한다. 사업장의 변경 정보의 비용이 비즈니스 가치보다 크지 않기 때문에 실시간으로 반영 될 필요는 없다. 고객(사용자)는 사업장의 상세 정보를 조회가 가능해야 한다.\n비기능 요구사항 낮은 Latency로 신속하게 검색이 되어야 하고 사용자의 위치정보나 사생활 보호 법안을 준수해야 한다. 인구 밀집 지역의 트래픽도 감당 가능해야 하기에 고가용성(high availability) 및 규모 확장성(scalability)을 고려해야 한다.\n이를 바탕으로 개략적인 규모 추정을 해보면 다음과 같다. 일간 능동 사용자(DAU, daily active user)는 1억명, 등록된 사업장 수는 2억이라고 가정하면,\nQPS (Query per Second) 계산\n1일 = 24시간 * 60분 *60초 = 86400초 ⇒ 대략 10^5초 한 사용자는 하루에 5회 검색 시도 QPS ⇒ (1억 * 5) / 10^5 = 5,000 2단계: 개략적 설계안 제시 및 동의 구하기 API 설계 특정 검색 기준에 맞는 사업장 목록을 반환하는 API는 아래의 정보로 구성해 볼 수 있다.\nRequest : GET /v1/search/nearby?latitude={}\u0026longitude={}\u0026radius={} Response { \"total\": 10, \"businesses\": [{business object}] // 사업장을 표현하는 객체 } 그리고 사업장에 관련된 API 들은 다음처럼 구성해볼수 있다.\nGET /vi/businesses/:id ⇒ 특정 사업장 상세 정보 반환 POST /v1/businesses ⇒ 새로운 사업장 추가 PUT /v1/businesses/:id ⇒ 사업장 정보 갱신 DELETE /v1/businesses/:id ⇒ 사업장 삭제 데이터 모델 요청의 형태를 들여다 보면 데이터 모델을 결정하는데 도움이 될수 있다. 해당 서비스의 특성상 읽기 비율이 쓰기 비율보다 월등이 높을것으로 예상되고 (읽기 요청 : 주변 사업장 검색, 사업장 정보 확인) 이렇게 읽기 빈도가 압도적으로 높은 경우에는 MySQL 같은 관계형 데이터베이스가 바람직 할 수 있다고 한다.\n읽기 빈도가 높은 경우에 관계형 데이터베이스가 더 좋은지에 대한 설명이 없어 아쉬웠다. 저자의 의견과는 반대로 읽기 빈도가 높은 경우 RDBMS보다는 NoSQL이 읽기 처리에 강점이 있다고 생각한다. 이 책에서는 단순히 데이터베이스만 보고 이야기 했던게 아니라 샤딩이나 복제 데이터베이스(주-부)같은 부가 기능들을 활용하기 위해서 빌드업을 한건 아닐까 생각을 해본다. 아래는 SQL vs NoSQL에 대한 아티클.\nhttps://velog.io/@park2348190/논문번역-SQL-vs-NoSQL-A-Performance-Comparison https://stackoverflow.com/questions/9702643/mysql-vs-mongodb-1000-reads 크게 사업장 상세 정보를 다루는 “사업장” 테이블과 위치 정보 관련 연산의 효율성을 높이는데 사용되는 “지리적 위치” 색인 테이블을 생각해 볼 수 있다.\n개략적 설계 시스템은 크게 LBS(Location Based Service, 위치기반 서비스)와 Businesses 두개의 컴포넌트로 구분된다. 가장 전면에 위치되는 로드밸런서는 유입 트래픽을 자동으로 각 서비스에 분산시킨다. 일반적으로 DNS로 단일 진입점을 만들고 URI에 따라 어느 서비스로 전달할지 결정하게 된다.\n위치기반 서비스는 시스템의 핵심 부분이며, 주어진 위치와 반경 정보를 이용해 주변 사업장을 검색한다. 쓰기 요청이 없는, 읽기 요청만 빈번하게 발생하는 서비스로 QPS가 높고 특정 시간대의 인구 밀집 지역일수록 그 경향이 심하게 된다. 다행히 무상태(stateless) 서비스이므로 수평적 규모 확장이 쉬운 특징이 있다. 사업장 서비스에서는 사업장 소유주가 사업장 정보를 CUD(Create/Update/Delete)를 하게 되고 고객이 사업장 정보를 조회한다. 특정 시간대에 QPS가 높아지는 경향이 있다.\n데이터베이스 클러스터는 주-부(primary-secondary) 데이터베이스 형태로 구성이 가능하다. 주 데이터베이스는 쓰기 요청을 처리하며, 사본 데이터베이스는 읽기 요청을 처리하여 부하를 분산 시키고 주 데이터베이스에 대한 replication에 지연이 있을 수 있으나 실시간으로 갱신될 필요가 적기 때문에 서비스 로직상 문제는 크리티컬하지 않는다고 판단한다.\n두 서비스 모두 무상태 서비스이므로 특정 시간대에 몰리는 트래픽에는 확장, 유휴 시간에는 축소로 대응할 수 있다. 또한 시스템을 클라우드에 둔다면 여러 지역, 여러 가용성 구역에 서버를 두어 가용성을 높일 수 있다.\n최근 회사에서 리소스 효율화 측면으로 컨테이너 기반의 서버들을 전수조사를 하였다. 너무 과하게 설정된 시스템 자원들에 대해 점검하고 축소하거나 HPA(Horizontal Pod Autoscaling)를 설정하여 트래픽이 많을때만 확장하여 사용하도록 했는데 운영환경에서 사용이 적은 새벽시간이나 개발환경의 경우 퇴근 또는 주말에는 자원을 최소화 하여 그 비용조차 아끼려는 노력을 해볼 수 있을 것 같다.\n주변 사업장 검색 알고리즘 어쩌면 이 챕터의 핵심이라 이야기 할 수 있는 부분이다. 대부분 geohash in redis나 PostGIS가 설치된 Postgres를 활용하지만 지리적 위치 색인이 어떻게 동작하는지에 대한 방법들을 알아보자.\n방안 1 : 2차원 검색 간단히 위도와 경도를 반경 기준으로 계산하여 쿼리로 질의하는 방식이다. 이는 테이블 전부를 읽어야 하므로 효율적이지 못할뿐더러 색인을 한다고 해도 데이터가 방대하여 효율이 썩 좋지는 않다.\nSELECT business_id, latitude, longitude FROM business WHERE (latitude BETWEEN {:my_lat} - radius AND {:my_lat} + radius) AND (longitude BETWEEN {:my_long} - radius AND {:my_long} + radius 방안 2 : 균등격자 지도를 단순히 작은 격자들로 나누는 방법인데 사업장 분포가 균등하지 않다는 문제가 있다. 태평양 한가운데에는 사업장이 없고, 뉴욕에는 너무 많은 사업장이 존재한다. 지역에 따라 격자의 크기를 다르게 만드는 방법이 있을 수 있지만 이또한 기준이 지역마다 모호하다. 더불어 인접 격자를 찾기 까다로울 수 있다.\n방안 3 : 지오해시 (Geohash) 간단하게 말해서 2차원의 위도 경도를 1차원의 문자열로 재생성한 것이라 보면 된다. 세계지도를 단계별로 사분면으로 나누고 이를 재귀적으로 반복하는 형태이다. 격자를 여러 단계로 나누는 정밀도(precision)는 12단계가 있는데 1단계(5,000km x 5,000km)부터 12단계(3.7cm x 1.9cm)중 적절한 정밀도를 선택해서 구현한다. 대게 잘 동작하지만 격자 가장자리 이슈가 있는데 일반적으로 인근 격자는 같은 접두어를 가지지만 적도의 위/아래 나, 자오선상의 양쪽으로 갈라지는 경우를 말한다. 아래와 같은 단순한 SQL 질의문을 사용하면 주변 모든 사업장을 가져올 수 있지만 가깝게 배치된 모든 사업장을 조회할수는 없다.\nSELECT * FROM geohash_index WHERE geohash LIKE \"9q8zn%\" 이 문제는 인접한 모든 격자를 함께 가져오는 방법으로 해결이 가능하다. 현재 cell 인근의 격자에 대한 hash 연산으로 상수 시간에 가능한 연산이기 때문이다.\n또 다른 이슈로 표시할 사업장이 충분하지 않는다는 이슈가 있다. 이때는 주어진 사업장만 반환하는 것으로 기능을 한정 짓거나 hash의 마지막 비트를 삭제하면서 geohash 값을 쉽게 키워서 검색할 수 있다.\nhttps://www.movable-type.co.uk/scripts/geohash.html\n지오해시는 통상적으로 base32을 사용한다. 예시로 계산을 해보면, 정밀도가 6이라 가정했을때 구글 본사의 지오해시는 10011101001001100011111111110 : 9q9hvu 가 되고 메타 본사의 지오해시는 10011101001001100111000111011 : 9q9jhr 가 된다.\n방안 4 : 쿼드트리 (Quadtree) 2차원 공간을 재귀적으로 분할하는 방식이다. 격자의 내용이 특정 기준(ex. 격자에 담긴 사업장 수가 100개 이하)을 만족할 떄까지 2차원 공간을 재귀적으로 사분면 분할하는데 흔히 사용되는 자료 구조이다.\n// 쿼드트리 만드는 예시 코드 public void buildQuadtree(TreeNode node) { if (countNumberOfBusinessesInCurrentGrid(node) \u003e 100 ) { node.subdivide(); for ( TreeNode child : node.getChildren() ) { buildQuadtree(child); } } } 질의에 응답할 트리 구조를 메모리에 올리게 된다. 데이터베이스가 아니기 때문에 LBS 서버가 시작될때 구축해서 가지고 있어야 한다. 쿼드트리의 노드는 세계 전체지도를 나타내고 하위노드로 내려갈수록 그 양은 많아져 메모리 사용량을 검토해야 하는데 아래 수식에 의하면 문제되는 수준은 아니게 된다.\n말단 노드 하나의 데이터 격자를 식별하는 데 사용될 좌상단과 우하단 꼭짓점 좌표 (32바이트) + 격자 내부 사업장 ID 목록 (ID당 8바이트 x 100) = 합계: 832바이트 내부 노드에 수록되는 데이터 격자를 식별하는데 사용될 좌상단과 우하단 꼭짓점 좌표 32바이트 + 하위 노드 4개를 가리킬 포인터 32 바이트 ( 8바이트 x 4 ) = 64 바이트 사업장의 정보는 database에 이미 레코드로 존재하기 때문에 계산에 포함하지 않는다. 최종 계산 : 말단 노드의 수 200만, 내부 노드의 수 67만(200만/3) * 832 바이트 =~ 1.7GB https://stackoverflow.com/questions/35976444/how-many-leaves-has-a-quadtree\n쿼드트리 구축에는 트리의 시간복잡도인 n log n 이 소요되므로 전체 사업장 수를 n 이라고 하고, 말단 노드에 대략 100개의 사업장이 저장된다 가정했을때 (n/100) log (n/100) 이 된다. 즉, 200백만개의 사업장 정보를 인덱싱하는 쿼드트리 구축에는 몇 분 정도 소요될 수 있지만 실제로는 단순 연산이 아니기 때문에 훨씬 더 많은 시간이 필요할 것으로 예상된다. 쿼드트리로 주변 사업장을 검색하기 위해서는 메모리에 쿼드트리 인덱스를 구축하고 검색 시작점이 포함된 말단 노드를 만날 때까지 트리의 루트 노드부터 탐색한다. 해당 노드에 100개 사업장이 있는 경우에 해당 노드만 반환하고 그렇지 않은 경우에는 충분한 사업장 수가 확보될 때까지 인접 노드도 추가하는 방식으로 처리하게 된다.\n쿼드트리 운영시에는 최초 쿼드트리 구축 시간이 걸리는 점을 고려해야 하는데 메모리에 올라가기 때문에 구축에 시간이 소요되므로 서버는 시작할때마다 수분의 서버 시작 시간이 발생한다. 이러한 이유로 동시에 너무 많은 서버개 배포되면 안되는데 서버 클러스터의 상당 부분이 동시에 꺼져서 서비스 품질이 저하될수 있고 동시에 배포 시 초기 트리 구조에 필요한 데이터를 받아오기 위해 DB 부담을 주는 상황이 발생한다. 또한 쿼드트리 갱신에 대한 고려가 되어야 하는데 점진적으로 갱신을 하는 간단한 방법을 적용해볼수 있다고 실시간 갱신도 가능하지만 설계가 많이 복잡해진다는 단점이 있다.\n방안 5 : 구글 S2 구글 S2 기하(geometry) 라이브러리로 힐베르트 곡선을 이용하여 지구를 1차원 색인화 하는 방법이다. 힐베르트 곡선 상에서 인접한 두 지점은 색인화 된 1차원 공간 내에서도 인접하다는 특성이 있고 2차원 공간을 1차원 공간으로 변경하면서 공간적 접근성을 유지할 수 있다.\n어떤 회사가 어떤 방법을 사용하는가 색인 방법 회사 Geohash Bing, Redis, MongoDB, Lyft Quadtree Yext Geohash+Quadtree Elasticsearch S2 Google,Tinder 지오해시 vs 쿼드트리 지오해시 구현과 사용이 쉽고 트리 구축이 필요 없음 지정 반경 내 사업장 검색 가능 동적인 격자 크기 조정이 어려움 색인의 갱신이 쉬움 쿼드트리 트리를 구축해야 하므로 구현상 고려할 부분이 더 많음 Top k를 쉽게 구할 수 있음 (가장 가까운 주유소 검색과 같은) 격자 크기를 동적으로 조정할 수 있음 색인의 갱신이 까다로움 사업장 정보를 삭제하기 위해 트리를 순회해야 함 트리의 리밸런싱에 대한 고려 필요(애초에 크게 잡는것으로 부분 해결 가능) 3단계: 상세 설계 4단계: 마무리 ","wordCount":"1515","inLanguage":"en","image":"https://team-json-delivery.github.io/images/system-design-interview-proximity-service/cover.png","datePublished":"2024-01-11T06:27:22+09:00","dateModified":"2024-01-11T06:27:22+09:00","author":{"@type":"Person","name":"taetaetae"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://team-json-delivery.github.io/posts/system-design-interview-proximity-service/"},"publisher":{"@type":"Organization","name":"Team JSON Delivery","logo":{"@type":"ImageObject","url":"https://team-json-delivery.github.io/%3Clink%20/%20abs%20url%3E"}}}</script><script>function changeGiscusTheme(){const e=document.body.classList.contains("dark")?"dark":"light";function t(e){const t=document.querySelector("iframe.giscus-frame");if(!t)return;t.contentWindow.postMessage({giscus:e},"https://giscus.app")}t({setConfig:{theme:e}})}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?(document.body.classList.add("dark"),setTimeout(changeGiscusTheme,2e3)):localStorage.getItem("pref-theme")==="light"?(document.body.classList.remove("dark"),setTimeout(changeGiscusTheme,2e3)):window.matchMedia("(prefers-color-scheme: dark)").matches&&(document.body.classList.add("dark"),setTimeout(changeGiscusTheme,2e3))</script><header class=header><nav class=nav><div class=logo><a href=https://team-json-delivery.github.io/ accesskey=h title="Team JSON Delivery (Alt + H)"><img src=https://team-json-delivery.github.io/apple-touch-icon.png alt aria-label=logo height=35>Team JSON Delivery</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://team-json-delivery.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://team-json-delivery.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://team-json-delivery.github.io/author/ title=author><span>author</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://team-json-delivery.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://team-json-delivery.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent" style=word-break:keep-all>주변 맛집을 찾으려면 어떻게 해야 검색이 빠를까?</h1><div class=post-meta><span title='2024-01-11 06:27:22 +0900 +0900'>2024년 01월 11일</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1515 words&nbsp;·&nbsp;taetaetae&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/system-design-interview-proximity-service.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><div id=figmask style=z-index:-1><img loading=eager src=https://team-json-delivery.github.io/images/system-design-interview-proximity-service/cover.png alt></div></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#1단계--문제-이해-및-설계-범위-확정>1단계 : 문제 이해 및 설계 범위 확정</a><ul><li><a href=#기능-요구사항>기능 요구사항</a></li><li><a href=#비기능-요구사항>비기능 요구사항</a></li></ul></li><li><a href=#2단계-개략적-설계안-제시-및-동의-구하기>2단계: 개략적 설계안 제시 및 동의 구하기</a><ul><li><a href=#api-설계>API 설계</a></li><li><a href=#데이터-모델>데이터 모델</a></li><li><a href=#개략적-설계>개략적 설계</a></li><li><a href=#주변-사업장-검색-알고리즘>주변 사업장 검색 알고리즘</a></li></ul></li><li><a href=#3단계-상세-설계>3단계: 상세 설계</a></li><li><a href=#4단계-마무리>4단계: 마무리</a></li></ul></nav></div></details></div><div class=post-content style=word-break:keep-all><p>　맛집을 찾으려 포털사이트에서 키워드로 검색하는 경우가 있다. &ldquo;중식 맛집&rdquo; 또는 &ldquo;분위기 좋은 카페&rdquo; 같은 특정 키워드로 검색을 하게 되면 블로그 후기를 본다거나 지도 서비스를 활용하여 어디에 있는지 위치를 확인한다. 블로그 후기의 경우 수많은 웹문서들을 검색 엔진이 미리 색인을 해두고 검색 키워드에 따라 결과를 보여주는 형태라고 가볍게 추측해볼수 있을것 같은데 지도상에 어디에 지점이 있는지 알려주는 지도 서비스에서는 어떻게 위치 기반으로 검색을 할 수 있을까? 단순히 위경도 기준으로 쿼리 돌려 조회하면 되겠지 싶다가도 국내를 넘어 글로벌 지도 서비스까지 생각해보면 그 양이 어마어마 할텐데 1초 이내로 검색이 빠르게 되는걸 보면 그저 대단하다 라고 생각하기엔 내부 구현이 궁금해진다.</p><p>　이번 글에서는 <a href=https://product.kyobobook.co.kr/detail/S000211656186>가상 면접 사례로 배우는 대규모 시스템 설계 기초 2</a>의 &ldquo;1장 근접성 서비스"라는 주제를 스터디하고 정리해보고자 한다. 위경도 좌표 기반의 검색이 어떻게 이루어 지고 어떤 측면을 고민하고 설계를 해야 하는지에 대한 내용이다. 물론, 국내를 비롯한 해외 지도 서비스들이 이 글에서 이야기 하고 있는 방식을 그대로 차용하진 않았을테고 또한 각 서비스마다(공개하기 어려운) 약간의 차이점이 있을수도 있겠지만 이렇게 상상을 해보는 과정에서 여러가지를 배울수 있을꺼라 기대해 본다.</p><hr><h2 id=1단계--문제-이해-및-설계-범위-확정>1단계 : 문제 이해 및 설계 범위 확정<a hidden class=anchor aria-hidden=true href=#1단계--문제-이해-및-설계-범위-확정>#</a></h2><p>　설계를 잘하기 위해서는 구현해야할 상황을 잘 파악하고 범위를 좁히는 것이 선행되어야 한다. 그렇지 않으면 오버 엔지니어링이 되거나 구현해야할 핵심과 가치에 벗어나는 설계가 될 수 있다. 크게 &ldquo;기능 요구사항"과 &ldquo;비기능 요구사항"으로 구분지어 범위를 정리해볼수 있다.</p><h3 id=기능-요구사항>기능 요구사항<a hidden class=anchor aria-hidden=true href=#기능-요구사항>#</a></h3><p>　사용자의 위치(위/경도)와 검색 반경 정보에 매치되는 사업장(지점)을 조회되어야 하고 사업장 소유주는 사업장의 정보를 추가, 수정, 삭제를 할 수 있어야 한다. 사업장의 변경 정보의 비용이 비즈니스 가치보다 크지 않기 때문에 실시간으로 반영 될 필요는 없다. 고객(사용자)는 사업장의 상세 정보를 조회가 가능해야 한다.</p><h3 id=비기능-요구사항>비기능 요구사항<a hidden class=anchor aria-hidden=true href=#비기능-요구사항>#</a></h3><p>　낮은 Latency로 신속하게 검색이 되어야 하고 사용자의 위치정보나 사생활 보호 법안을 준수해야 한다. 인구 밀집 지역의 트래픽도 감당 가능해야 하기에 고가용성(high availability) 및 규모 확장성(scalability)을 고려해야 한다.</p><p>　이를 바탕으로 개략적인 규모 추정을 해보면 다음과 같다. 일간 능동 사용자(DAU, daily active user)는 1억명, 등록된 사업장 수는 2억이라고 가정하면,</p><p>QPS (Query per Second) 계산</p><ul><li>1일 = 24시간 * 60분 *60초 = 86400초 ⇒ 대략 10^5초</li><li>한 사용자는 하루에 5회 검색 시도</li><li>QPS ⇒ (1억 * 5) / 10^5 = 5,000</li></ul><hr><h2 id=2단계-개략적-설계안-제시-및-동의-구하기>2단계: 개략적 설계안 제시 및 동의 구하기<a hidden class=anchor aria-hidden=true href=#2단계-개략적-설계안-제시-및-동의-구하기>#</a></h2><h3 id=api-설계>API 설계<a hidden class=anchor aria-hidden=true href=#api-설계>#</a></h3><p>　특정 검색 기준에 맞는 사업장 목록을 반환하는 API는 아래의 정보로 구성해 볼 수 있다.</p><ul><li>Request : GET /v1/search/nearby?latitude={}&amp;longitude={}&amp;radius={}</li><li>Response<div class=highlight><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;total&#34;</span><span class=p>:</span> <span class=mi>10</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;businesses&#34;</span><span class=p>:</span> <span class=p>[{</span><span class=err>business</span> <span class=err>object</span><span class=p>}]</span> <span class=c1>// 사업장을 표현하는 객체 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div></li></ul><p>그리고 사업장에 관련된 API 들은 다음처럼 구성해볼수 있다.</p><ul><li>GET /vi/businesses/:id ⇒ 특정 사업장 상세 정보 반환</li><li>POST /v1/businesses ⇒ 새로운 사업장 추가</li><li>PUT /v1/businesses/:id ⇒ 사업장 정보 갱신</li><li>DELETE /v1/businesses/:id ⇒ 사업장 삭제</li></ul><h3 id=데이터-모델>데이터 모델<a hidden class=anchor aria-hidden=true href=#데이터-모델>#</a></h3><p>　요청의 형태를 들여다 보면 데이터 모델을 결정하는데 도움이 될수 있다. 해당 서비스의 특성상 읽기 비율이 쓰기 비율보다 월등이 높을것으로 예상되고 (읽기 요청 : 주변 사업장 검색, 사업장 정보 확인) 이렇게 읽기 빈도가 압도적으로 높은 경우에는 MySQL 같은 관계형 데이터베이스가 바람직 할 수 있다고 한다.</p><blockquote><p>읽기 빈도가 높은 경우에 관계형 데이터베이스가 더 좋은지에 대한 설명이 없어 아쉬웠다. 저자의 의견과는 반대로 읽기 빈도가 높은 경우 RDBMS보다는 NoSQL이 읽기 처리에 강점이 있다고 생각한다. 이 책에서는 단순히 데이터베이스만 보고 이야기 했던게 아니라 샤딩이나 복제 데이터베이스(주-부)같은 부가 기능들을 활용하기 위해서 빌드업을 한건 아닐까 생각을 해본다. 아래는 SQL vs NoSQL에 대한 아티클.</p><ul><li><a href=https://velog.io/@park2348190/%EB%85%BC%EB%AC%B8%EB%B2%88%EC%97%AD-SQL-vs-NoSQL-A-Performance-Comparison>https://velog.io/@park2348190/논문번역-SQL-vs-NoSQL-A-Performance-Comparison</a></li><li><a href=https://stackoverflow.com/questions/9702643/mysql-vs-mongodb-1000-reads>https://stackoverflow.com/questions/9702643/mysql-vs-mongodb-1000-reads</a></li></ul></blockquote><p>　크게 사업장 상세 정보를 다루는 &ldquo;사업장&rdquo; 테이블과 위치 정보 관련 연산의 효율성을 높이는데 사용되는 &ldquo;지리적 위치&rdquo; 색인 테이블을 생각해 볼 수 있다.</p><h3 id=개략적-설계>개략적 설계<a hidden class=anchor aria-hidden=true href=#개략적-설계>#</a></h3><p>　시스템은 크게 LBS(Location Based Service, 위치기반 서비스)와 Businesses 두개의 컴포넌트로 구분된다. 가장 전면에 위치되는 로드밸런서는 유입 트래픽을 자동으로 각 서비스에 분산시킨다. 일반적으로 DNS로 단일 진입점을 만들고 URI에 따라 어느 서비스로 전달할지 결정하게 된다.</p><p>　위치기반 서비스는 시스템의 핵심 부분이며, 주어진 위치와 반경 정보를 이용해 주변 사업장을 검색한다. 쓰기 요청이 없는, 읽기 요청만 빈번하게 발생하는 서비스로 QPS가 높고 특정 시간대의 인구 밀집 지역일수록 그 경향이 심하게 된다. 다행히 무상태(stateless) 서비스이므로 수평적 규모 확장이 쉬운 특징이 있다. 사업장 서비스에서는 사업장 소유주가 사업장 정보를 CUD(Create/Update/Delete)를 하게 되고 고객이 사업장 정보를 조회한다. 특정 시간대에 QPS가 높아지는 경향이 있다.</p><p>　데이터베이스 클러스터는 주-부(primary-secondary) 데이터베이스 형태로 구성이 가능하다. 주 데이터베이스는 쓰기 요청을 처리하며, 사본 데이터베이스는 읽기 요청을 처리하여 부하를 분산 시키고 주 데이터베이스에 대한 replication에 지연이 있을 수 있으나 실시간으로 갱신될 필요가 적기 때문에 서비스 로직상 문제는 크리티컬하지 않는다고 판단한다.</p><p>　두 서비스 모두 무상태 서비스이므로 특정 시간대에 몰리는 트래픽에는 확장, 유휴 시간에는 축소로 대응할 수 있다. 또한 시스템을 클라우드에 둔다면 여러 지역, 여러 가용성 구역에 서버를 두어 가용성을 높일 수 있다.</p><blockquote><p>최근 회사에서 리소스 효율화 측면으로 컨테이너 기반의 서버들을 전수조사를 하였다. 너무 과하게 설정된 시스템 자원들에 대해 점검하고 축소하거나 HPA(Horizontal Pod Autoscaling)를 설정하여 트래픽이 많을때만 확장하여 사용하도록 했는데 운영환경에서 사용이 적은 새벽시간이나 개발환경의 경우 퇴근 또는 주말에는 자원을 최소화 하여 그 비용조차 아끼려는 노력을 해볼 수 있을 것 같다.</p></blockquote><h3 id=주변-사업장-검색-알고리즘>주변 사업장 검색 알고리즘<a hidden class=anchor aria-hidden=true href=#주변-사업장-검색-알고리즘>#</a></h3><p>　어쩌면 이 챕터의 핵심이라 이야기 할 수 있는 부분이다. 대부분 geohash in redis나 PostGIS가 설치된 Postgres를 활용하지만 지리적 위치 색인이 어떻게 동작하는지에 대한 방법들을 알아보자.</p><h4 id=방안-1--2차원-검색>방안 1 : 2차원 검색<a hidden class=anchor aria-hidden=true href=#방안-1--2차원-검색>#</a></h4><p>　간단히 위도와 경도를 반경 기준으로 계산하여 쿼리로 질의하는 방식이다. 이는 테이블 전부를 읽어야 하므로 효율적이지 못할뿐더러 색인을 한다고 해도 데이터가 방대하여 효율이 썩 좋지는 않다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>business_id</span><span class=p>,</span><span class=w> </span><span class=n>latitude</span><span class=p>,</span><span class=w> </span><span class=n>longitude</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FROM</span><span class=w> </span><span class=n>business</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>WHERE</span><span class=w> </span><span class=p>(</span><span class=n>latitude</span><span class=w> </span><span class=k>BETWEEN</span><span class=w> </span><span class=err>{</span><span class=p>:</span><span class=n>my_lat</span><span class=err>}</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>radius</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=err>{</span><span class=p>:</span><span class=n>my_lat</span><span class=err>}</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>radius</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>AND</span><span class=w> </span><span class=p>(</span><span class=n>longitude</span><span class=w> </span><span class=k>BETWEEN</span><span class=w> </span><span class=err>{</span><span class=p>:</span><span class=n>my_long</span><span class=err>}</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>radius</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=err>{</span><span class=p>:</span><span class=n>my_long</span><span class=err>}</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>radius</span><span class=w>
</span></span></span></code></pre></div><h4 id=방안-2--균등격자>방안 2 : 균등격자<a hidden class=anchor aria-hidden=true href=#방안-2--균등격자>#</a></h4><p>　지도를 단순히 작은 격자들로 나누는 방법인데 사업장 분포가 균등하지 않다는 문제가 있다. 태평양 한가운데에는 사업장이 없고, 뉴욕에는 너무 많은 사업장이 존재한다. 지역에 따라 격자의 크기를 다르게 만드는 방법이 있을 수 있지만 이또한 기준이 지역마다 모호하다. 더불어 인접 격자를 찾기 까다로울 수 있다.</p><h4 id=방안-3--지오해시-geohash>방안 3 : 지오해시 (Geohash)<a hidden class=anchor aria-hidden=true href=#방안-3--지오해시-geohash>#</a></h4><p>　간단하게 말해서 2차원의 위도 경도를 1차원의 문자열로 재생성한 것이라 보면 된다. 세계지도를 단계별로 사분면으로 나누고 이를 재귀적으로 반복하는 형태이다. 격자를 여러 단계로 나누는 정밀도(precision)는 12단계가 있는데 1단계(5,000km x 5,000km)부터 12단계(3.7cm x 1.9cm)중 적절한 정밀도를 선택해서 구현한다. 대게 잘 동작하지만 격자 가장자리 이슈가 있는데 일반적으로 인근 격자는 같은 접두어를 가지지만 적도의 위/아래 나, 자오선상의 양쪽으로 갈라지는 경우를 말한다. 아래와 같은 단순한 SQL 질의문을 사용하면 주변 모든 사업장을 가져올 수 있지만 가깝게 배치된 모든 사업장을 조회할수는 없다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>geohash_index</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>geohash</span><span class=w> </span><span class=k>LIKE</span><span class=w> </span><span class=s2>&#34;9q8zn%&#34;</span><span class=w>
</span></span></span></code></pre></div><p>이 문제는 인접한 모든 격자를 함께 가져오는 방법으로 해결이 가능하다. 현재 cell 인근의 격자에 대한 hash 연산으로 상수 시간에 가능한 연산이기 때문이다.</p><p>　또 다른 이슈로 표시할 사업장이 충분하지 않는다는 이슈가 있다. 이때는 주어진 사업장만 반환하는 것으로 기능을 한정 짓거나 hash의 마지막 비트를 삭제하면서 geohash 값을 쉽게 키워서 검색할 수 있다.</p><blockquote><p><a href=https://www.movable-type.co.uk/scripts/geohash.html>https://www.movable-type.co.uk/scripts/geohash.html</a></p></blockquote><p>　지오해시는 통상적으로 base32을 사용한다. 예시로 계산을 해보면, 정밀도가 6이라 가정했을때 구글 본사의 지오해시는 10011101001001100011111111110 : 9q9hvu 가 되고 메타 본사의 지오해시는 10011101001001100111000111011 : 9q9jhr 가 된다.</p><h4 id=방안-4--쿼드트리-quadtree>방안 4 : 쿼드트리 (Quadtree)<a hidden class=anchor aria-hidden=true href=#방안-4--쿼드트리-quadtree>#</a></h4><p>　2차원 공간을 재귀적으로 분할하는 방식이다. 격자의 내용이 특정 기준(ex. 격자에 담긴 사업장 수가 100개 이하)을 만족할 떄까지 2차원 공간을 재귀적으로 사분면 분할하는데 흔히 사용되는 자료 구조이다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 쿼드트리 만드는 예시 코드</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>buildQuadtree</span><span class=p>(</span><span class=n>TreeNode</span><span class=w> </span><span class=n>node</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>countNumberOfBusinessesInCurrentGrid</span><span class=p>(</span><span class=n>node</span><span class=p>)</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>100</span><span class=w> </span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=n>node</span><span class=p>.</span><span class=na>subdivide</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=w> </span><span class=n>TreeNode</span><span class=w> </span><span class=n>child</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>node</span><span class=p>.</span><span class=na>getChildren</span><span class=p>()</span><span class=w> </span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=n>buildQuadtree</span><span class=p>(</span><span class=n>child</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>　질의에 응답할 트리 구조를 메모리에 올리게 된다. 데이터베이스가 아니기 때문에 LBS 서버가 시작될때 구축해서 가지고 있어야 한다. 쿼드트리의 노드는 세계 전체지도를 나타내고 하위노드로 내려갈수록 그 양은 많아져 메모리 사용량을 검토해야 하는데 아래 수식에 의하면 문제되는 수준은 아니게 된다.</p><ul><li>말단 노드 하나의 데이터<ul><li>격자를 식별하는 데 사용될 좌상단과 우하단 꼭짓점 좌표 (32바이트) + 격자 내부 사업장 ID 목록 (ID당 8바이트 x 100) = 합계: 832바이트</li></ul></li><li>내부 노드에 수록되는 데이터<ul><li>격자를 식별하는데 사용될 좌상단과 우하단 꼭짓점 좌표 32바이트 + 하위 노드 4개를 가리킬 포인터 32 바이트 ( 8바이트 x 4 ) = 64 바이트</li></ul></li><li>사업장의 정보는 database에 이미 레코드로 존재하기 때문에 계산에 포함하지 않는다.</li><li>최종 계산 : 말단 노드의 수 200만, 내부 노드의 수 67만(200만/3) * 832 바이트 =~ 1.7GB</li></ul><blockquote><p><a href=https://stackoverflow.com/questions/35976444/how-many-leaves-has-a-quadtree>https://stackoverflow.com/questions/35976444/how-many-leaves-has-a-quadtree</a></p></blockquote><p>　쿼드트리 구축에는 트리의 시간복잡도인 n log n 이 소요되므로 전체 사업장 수를 n 이라고 하고, 말단 노드에 대략 100개의 사업장이 저장된다 가정했을때 (n/100) log (n/100) 이 된다. 즉, 200백만개의 사업장 정보를 인덱싱하는 쿼드트리 구축에는 몇 분 정도 소요될 수 있지만 실제로는 단순 연산이 아니기 때문에 훨씬 더 많은 시간이 필요할 것으로 예상된다. 쿼드트리로 주변 사업장을 검색하기 위해서는 메모리에 쿼드트리 인덱스를 구축하고 검색 시작점이 포함된 말단 노드를 만날 때까지 트리의 루트 노드부터 탐색한다. 해당 노드에 100개 사업장이 있는 경우에 해당 노드만 반환하고 그렇지 않은 경우에는 충분한 사업장 수가 확보될 때까지 인접 노드도 추가하는 방식으로 처리하게 된다.</p><p>　쿼드트리 운영시에는 최초 쿼드트리 구축 시간이 걸리는 점을 고려해야 하는데 메모리에 올라가기 때문에 구축에 시간이 소요되므로 서버는 시작할때마다 수분의 서버 시작 시간이 발생한다. 이러한 이유로 동시에 너무 많은 서버개 배포되면 안되는데 서버 클러스터의 상당 부분이 동시에 꺼져서 서비스 품질이 저하될수 있고 동시에 배포 시 초기 트리 구조에 필요한 데이터를 받아오기 위해 DB 부담을 주는 상황이 발생한다. 또한 쿼드트리 갱신에 대한 고려가 되어야 하는데 점진적으로 갱신을 하는 간단한 방법을 적용해볼수 있다고 실시간 갱신도 가능하지만 설계가 많이 복잡해진다는 단점이 있다.</p><h4 id=방안-5--구글-s2>방안 5 : 구글 S2<a hidden class=anchor aria-hidden=true href=#방안-5--구글-s2>#</a></h4><p>　구글 S2 기하(geometry) 라이브러리로 힐베르트 곡선을 이용하여 지구를 1차원 색인화 하는 방법이다. 힐베르트 곡선 상에서 인접한 두 지점은 색인화 된 1차원 공간 내에서도 인접하다는 특성이 있고 2차원 공간을 1차원 공간으로 변경하면서 공간적 접근성을 유지할 수 있다.</p><h4 id=어떤-회사가-어떤-방법을-사용하는가>어떤 회사가 어떤 방법을 사용하는가<a hidden class=anchor aria-hidden=true href=#어떤-회사가-어떤-방법을-사용하는가>#</a></h4><table><thead><tr><th>색인 방법</th><th>회사</th></tr></thead><tbody><tr><td>Geohash</td><td>Bing, Redis, MongoDB, Lyft</td></tr><tr><td>Quadtree</td><td>Yext</td></tr><tr><td>Geohash+Quadtree</td><td>Elasticsearch</td></tr><tr><td>S2</td><td>Google,Tinder</td></tr></tbody></table><h4 id=지오해시-vs-쿼드트리>지오해시 vs 쿼드트리<a hidden class=anchor aria-hidden=true href=#지오해시-vs-쿼드트리>#</a></h4><ul><li>지오해시<ul><li>구현과 사용이 쉽고 트리 구축이 필요 없음</li><li>지정 반경 내 사업장 검색 가능</li><li>동적인 격자 크기 조정이 어려움</li><li>색인의 갱신이 쉬움</li></ul></li><li>쿼드트리<ul><li>트리를 구축해야 하므로 구현상 고려할 부분이 더 많음</li><li>Top k를 쉽게 구할 수 있음 (가장 가까운 주유소 검색과 같은)</li><li>격자 크기를 동적으로 조정할 수 있음</li><li>색인의 갱신이 까다로움<ul><li>사업장 정보를 삭제하기 위해 트리를 순회해야 함</li><li>트리의 리밸런싱에 대한 고려 필요(애초에 크게 잡는것으로 부분 해결 가능)</li></ul></li></ul></li></ul><hr><h2 id=3단계-상세-설계>3단계: 상세 설계<a hidden class=anchor aria-hidden=true href=#3단계-상세-설계>#</a></h2><hr><h2 id=4단계-마무리>4단계: 마무리<a hidden class=anchor aria-hidden=true href=#4단계-마무리>#</a></h2></div><footer class=post-footer><ul class=post-tags></ul><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 주변 맛집을 찾으려면 어떻게 해야 검색이 빠를까? on x" href="https://x.com/intent/tweet/?text=%ec%a3%bc%eb%b3%80%20%eb%a7%9b%ec%a7%91%ec%9d%84%20%ec%b0%be%ec%9c%bc%eb%a0%a4%eb%a9%b4%20%ec%96%b4%eb%96%bb%ea%b2%8c%20%ed%95%b4%ec%95%bc%20%ea%b2%80%ec%83%89%ec%9d%b4%20%eb%b9%a0%eb%a5%bc%ea%b9%8c%3f&amp;url=https%3a%2f%2fteam-json-delivery.github.io%2fposts%2fsystem-design-interview-proximity-service%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 주변 맛집을 찾으려면 어떻게 해야 검색이 빠를까? on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fteam-json-delivery.github.io%2fposts%2fsystem-design-interview-proximity-service%2f&amp;title=%ec%a3%bc%eb%b3%80%20%eb%a7%9b%ec%a7%91%ec%9d%84%20%ec%b0%be%ec%9c%bc%eb%a0%a4%eb%a9%b4%20%ec%96%b4%eb%96%bb%ea%b2%8c%20%ed%95%b4%ec%95%bc%20%ea%b2%80%ec%83%89%ec%9d%b4%20%eb%b9%a0%eb%a5%bc%ea%b9%8c%3f&amp;summary=%ec%a3%bc%eb%b3%80%20%eb%a7%9b%ec%a7%91%ec%9d%84%20%ec%b0%be%ec%9c%bc%eb%a0%a4%eb%a9%b4%20%ec%96%b4%eb%96%bb%ea%b2%8c%20%ed%95%b4%ec%95%bc%20%ea%b2%80%ec%83%89%ec%9d%b4%20%eb%b9%a0%eb%a5%bc%ea%b9%8c%3f&amp;source=https%3a%2f%2fteam-json-delivery.github.io%2fposts%2fsystem-design-interview-proximity-service%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 주변 맛집을 찾으려면 어떻게 해야 검색이 빠를까? on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fteam-json-delivery.github.io%2fposts%2fsystem-design-interview-proximity-service%2f&title=%ec%a3%bc%eb%b3%80%20%eb%a7%9b%ec%a7%91%ec%9d%84%20%ec%b0%be%ec%9c%bc%eb%a0%a4%eb%a9%b4%20%ec%96%b4%eb%96%bb%ea%b2%8c%20%ed%95%b4%ec%95%bc%20%ea%b2%80%ec%83%89%ec%9d%b4%20%eb%b9%a0%eb%a5%bc%ea%b9%8c%3f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 주변 맛집을 찾으려면 어떻게 해야 검색이 빠를까? on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fteam-json-delivery.github.io%2fposts%2fsystem-design-interview-proximity-service%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 주변 맛집을 찾으려면 어떻게 해야 검색이 빠를까? on whatsapp" href="https://api.whatsapp.com/send?text=%ec%a3%bc%eb%b3%80%20%eb%a7%9b%ec%a7%91%ec%9d%84%20%ec%b0%be%ec%9c%bc%eb%a0%a4%eb%a9%b4%20%ec%96%b4%eb%96%bb%ea%b2%8c%20%ed%95%b4%ec%95%bc%20%ea%b2%80%ec%83%89%ec%9d%b4%20%eb%b9%a0%eb%a5%bc%ea%b9%8c%3f%20-%20https%3a%2f%2fteam-json-delivery.github.io%2fposts%2fsystem-design-interview-proximity-service%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 주변 맛집을 찾으려면 어떻게 해야 검색이 빠를까? on telegram" href="https://telegram.me/share/url?text=%ec%a3%bc%eb%b3%80%20%eb%a7%9b%ec%a7%91%ec%9d%84%20%ec%b0%be%ec%9c%bc%eb%a0%a4%eb%a9%b4%20%ec%96%b4%eb%96%bb%ea%b2%8c%20%ed%95%b4%ec%95%bc%20%ea%b2%80%ec%83%89%ec%9d%b4%20%eb%b9%a0%eb%a5%bc%ea%b9%8c%3f&amp;url=https%3a%2f%2fteam-json-delivery.github.io%2fposts%2fsystem-design-interview-proximity-service%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 주변 맛집을 찾으려면 어떻게 해야 검색이 빠를까? on ycombinator" href="https://news.ycombinator.com/submitlink?t=%ec%a3%bc%eb%b3%80%20%eb%a7%9b%ec%a7%91%ec%9d%84%20%ec%b0%be%ec%9c%bc%eb%a0%a4%eb%a9%b4%20%ec%96%b4%eb%96%bb%ea%b2%8c%20%ed%95%b4%ec%95%bc%20%ea%b2%80%ec%83%89%ec%9d%b4%20%eb%b9%a0%eb%a5%bc%ea%b9%8c%3f&u=https%3a%2f%2fteam-json-delivery.github.io%2fposts%2fsystem-design-interview-proximity-service%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://giscus.app/client.js data-repo=team-json-delivery/team-json-delivery.github.io data-repo-id=R_kgDOLAMZNQ data-category=comment data-category-id=DIC_kwDOLAMZNc4CcJ4o data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=ko crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://team-json-delivery.github.io/>Team JSON Delivery</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light"),changeGiscusTheme()):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"),changeGiscusTheme())})</script></body></html>