<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>쓰지만 말고 직접 구현해보자! 분산 메시지큐! | Team JSON Delivery</title>
<meta name=keywords content><meta name=description content="쓰지만 말고 직접 구현해보자! 분산 메시지큐! MSA(Microservice Architecture)가 아키텍처 설계의 트랜드가 되면서 메시지 큐는 시스템 구성의 중요한 요소로 자리잡았습니다. 이번 글에서는 가상 면접 사례로 배우는 대규모 시스템 설계 기초 2 4장 분산 메시지 큐를 소개하려고 합니다.
분산 메시지 큐의 특징을 간단히 알아보고, 기본적인 요소를 설계해봅시다.
(메세지 큐를 구성하는 요소가 방대한 만큼 세부 개념에 대한 자세한 설명은 넘어가겠습니다.)
본격적인 설계에 앞서 메시지 큐의 기능을 생각해봅시다.
1. 프로듀서는 메시지 큐에 메시지를 보낼 수 있어야 합니다."><meta name=author content="junho3"><link rel=canonical href=https://team-json-delivery.github.io/posts/%EB%B6%84%EC%82%B0-%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.bd435680923be95168ea1b839ff6ad8e781ccaf43d48e00fadcb1ff771ce3c90.css integrity="sha256-vUNWgJI76VFo6huDn/atjngcyvQ9SOAPrcsf93HOPJA=" rel="preload stylesheet" as=style><link rel=icon href=https://team-json-delivery.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://team-json-delivery.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://team-json-delivery.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://team-json-delivery.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://team-json-delivery.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://team-json-delivery.github.io/posts/%EB%B6%84%EC%82%B0-%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-Y39RPCVCBC"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-Y39RPCVCBC",{anonymize_ip:!1})}</script><meta property="og:title" content="쓰지만 말고 직접 구현해보자! 분산 메시지큐!"><meta property="og:description" content="쓰지만 말고 직접 구현해보자! 분산 메시지큐! MSA(Microservice Architecture)가 아키텍처 설계의 트랜드가 되면서 메시지 큐는 시스템 구성의 중요한 요소로 자리잡았습니다. 이번 글에서는 가상 면접 사례로 배우는 대규모 시스템 설계 기초 2 4장 분산 메시지 큐를 소개하려고 합니다.
분산 메시지 큐의 특징을 간단히 알아보고, 기본적인 요소를 설계해봅시다.
(메세지 큐를 구성하는 요소가 방대한 만큼 세부 개념에 대한 자세한 설명은 넘어가겠습니다.)
본격적인 설계에 앞서 메시지 큐의 기능을 생각해봅시다.
1. 프로듀서는 메시지 큐에 메시지를 보낼 수 있어야 합니다."><meta property="og:type" content="article"><meta property="og:url" content="https://team-json-delivery.github.io/posts/%EB%B6%84%EC%82%B0-%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/"><meta property="og:image" content="https://team-json-delivery.github.io/images/message-queue/cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-02-27T09:00:00+09:00"><meta property="article:modified_time" content="2024-02-27T09:00:00+09:00"><meta property="og:site_name" content="Team JSON Delivery"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://team-json-delivery.github.io/images/message-queue/cover.png"><meta name=twitter:title content="쓰지만 말고 직접 구현해보자! 분산 메시지큐!"><meta name=twitter:description content="쓰지만 말고 직접 구현해보자! 분산 메시지큐! MSA(Microservice Architecture)가 아키텍처 설계의 트랜드가 되면서 메시지 큐는 시스템 구성의 중요한 요소로 자리잡았습니다. 이번 글에서는 가상 면접 사례로 배우는 대규모 시스템 설계 기초 2 4장 분산 메시지 큐를 소개하려고 합니다.
분산 메시지 큐의 특징을 간단히 알아보고, 기본적인 요소를 설계해봅시다.
(메세지 큐를 구성하는 요소가 방대한 만큼 세부 개념에 대한 자세한 설명은 넘어가겠습니다.)
본격적인 설계에 앞서 메시지 큐의 기능을 생각해봅시다.
1. 프로듀서는 메시지 큐에 메시지를 보낼 수 있어야 합니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://team-json-delivery.github.io/posts/"},{"@type":"ListItem","position":2,"name":"쓰지만 말고 직접 구현해보자! 분산 메시지큐!","item":"https://team-json-delivery.github.io/posts/%EB%B6%84%EC%82%B0-%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"쓰지만 말고 직접 구현해보자! 분산 메시지큐!","name":"쓰지만 말고 직접 구현해보자! 분산 메시지큐!","description":"쓰지만 말고 직접 구현해보자! 분산 메시지큐! MSA(Microservice Architecture)가 아키텍처 설계의 트랜드가 되면서 메시지 큐는 시스템 구성의 중요한 요소로 자리잡았습니다. 이번 글에서는 가상 면접 사례로 배우는 대규모 시스템 설계 기초 2 4장 분산 메시지 큐를 소개하려고 합니다.\n분산 메시지 큐의 특징을 간단히 알아보고, 기본적인 요소를 설계해봅시다.\n(메세지 큐를 구성하는 요소가 방대한 만큼 세부 개념에 대한 자세한 설명은 넘어가겠습니다.)\n본격적인 설계에 앞서 메시지 큐의 기능을 생각해봅시다.\n1. 프로듀서는 메시지 큐에 메시지를 보낼 수 있어야 합니다.","keywords":[],"articleBody":"쓰지만 말고 직접 구현해보자! 분산 메시지큐! MSA(Microservice Architecture)가 아키텍처 설계의 트랜드가 되면서 메시지 큐는 시스템 구성의 중요한 요소로 자리잡았습니다. 이번 글에서는 가상 면접 사례로 배우는 대규모 시스템 설계 기초 2 4장 분산 메시지 큐를 소개하려고 합니다.\n분산 메시지 큐의 특징을 간단히 알아보고, 기본적인 요소를 설계해봅시다.\n(메세지 큐를 구성하는 요소가 방대한 만큼 세부 개념에 대한 자세한 설명은 넘어가겠습니다.)\n본격적인 설계에 앞서 메시지 큐의 기능을 생각해봅시다.\n1. 프로듀서는 메시지 큐에 메시지를 보낼 수 있어야 합니다. 2. 컨슈머는 메시지 큐를 통해 메시지를 수신할 수 있어야 합니다. 3. 하나의 메시지를 서로 다른 컨슈머가 수신할 수 있어야 합니다. 4. 메시지가 생산된 순서대로 소비될 수 있도록 순서를 보장해야 합니다. 5. 오래된 이력 데이터는 삭제될 수 있습니다. 6. 메시지 크기는 킬로바이트 수준입니다. 7. 메시지는 최소 한 번, 최대 한 번, 정확히 한 번 가운데 설정할 수 있어야 합니다.` 메시지 큐의 비기능 요구사항은 3가지가 있습니다.\n1. 높은 대역폭과 낮은 전송 지연 중 하나를 설정으로 선택 가능해야 합니다. 2. 메시지 양이 급증해도 처리 가능해야 합니다. 3. 데이터는 디스크에 보관되어야 하며 여러 노드에 복제되어야 합니다. Kafka와 RabbitMQ의 차이점은 무엇인가요?\nhttps://aws.amazon.com/ko/compare/the-difference-between-rabbitmq-and-kafka/\n메시지큐와 Kafka의 기본적인 특징을 소개한 블로그입니다.\n카프카가 무엇이고, 왜 사용하는 것 일까?\nhttps://hudi.blog/what-is-kafka/\n다음으로 프로듀서에서 발행한 메시지가 컨슈머까지 어떻게 전달되는지 흐름을 생각해봅시다.\n책에서는 일대일 모델부터 단계적으로 소개하고 있지만, 이 글에서는 발행(Pub)-구독(Sub) 모델 기반의 최종 모습만 소개하겠습니다.\n1. 주문 서비스(프로듀서)가 주문완료 이벤트 메시지를 발행합니다. 2. 메시지가 주문완료 토픽에 도착합니다. 3. 토픽에 도착한 메시지는 라운드 로빈 등의 방식으로 파티션에 분배됩니다. 4. 주문완료 토픽을 구독하고 있는 배송 컨슈머와 주문완료 알림톡 컨슈머는 수신 받은 메시지를 처리합니다. 위 이미지와 같이 프로듀서가 토픽에 메시지를 발행하고, 컨슈머 그룹이 토픽(파티션)의 메시지를 구독한다면 요구사항 1~3번을 달성할 수 있습니다.\n한 가지 중요하게 생각해볼 것은 브로커가 메시지를 컨슈머에게 보낼 것(푸시 모델)인가 아니면 컨슈머가 브로커에서 가져갈 것(풀 모델) 인지입니다.\n푸시 모델(RabbitMQ, ActiveMQ)과 풀 모델(Kafka)은 각각 장단점이 있어 요구사항에 적합한 모델 선택이 중요합니다.\n발행-구독 모델\nhttps://ko.wikipedia.org/wiki/%EB%B0%9C%ED%96%89-%EA%B5%AC%EB%8F%85_%EB%AA%A8%EB%8D%B8\n메시지의 순서는 어떻게 보장할 수 있을까요?\n파티션은 FIFO 큐처럼 동작하므로 같은 파티션 안에서는 메시지 순서를 보장할 수 있습니다.\n하지만 토픽 관점에서는 순서를 보장할 수 없기 때문에 메시지에 키를 할당해야 합니다.\n위 이미지처럼 같은 키를 가진 메시지를 같은 파티션으로 보낸다면 키를 가진 메시지는 순서를 보장할 수 있게 됩니다.\n물론, 메시지 키를 할당하여도 토픽 관점에서 완벽한 순서 보장은 어렵습니다.\n한 스터디원에 따르면, 컨슈머는 메시지를 DB에 적재하고 별도 배치 등으로 DB에 적재 된 데이터를 기준 시간 순으로 정렬하여 처리한 경험을 공유해주셨습니다.\n데이터의 장기 보관 요구사항을 만족하면서 높은 대역폭을 제공하려면 데이터 저장소와 적재 방식을 고민해야 합니다.\n메시지 큐는 읽기와 쓰기가 대규모로 빈번하게 일어나기 때문에 파일에 저장하는 것이 적합합니다.\n책에서는 쓰기 우선 로그(Write-Ahead Log, WAL)을 소개하고 있는데, 새로운 항목이 추가되기만 하는 일반적인 파일 구조입니다.\n또한, 파일이 무한정 커질 것을 대비하여 세그먼트 단위로 파일을 분할해야 합니다.\n위와 같이 토픽의 파티션 하위에 세그먼트별로 WAL을 관리한다면, 용량 한계에 도달하거나 보관 기간이 만료된 오래된 세그먼트 파일을 삭제할 수 있습니다.\n책에서는 회전 디스크 사용과 배치 처리 등 I/O를 줄이는 방법도 소개하고 있습니다.\n메시지 큐는 내부적으로 다양한 메타 정보를 관리해야 합니다.\n- 파티션에 할당된 컨슈머 정보 - 컨슈머가 읽어간 마지막 메시지의 오프셋 - 토픽 설정이나 속성 정보 - 메시지 및 사본 등 기타 정보 위와 같은 정보들은 높은 일관성을 요구하므로 Apache ZooKeeper 같은 키-값 저장소를 고려하는 것이 적합합니다.\n또한, 주키퍼는 브로커의 리더 선출 과정을 돕기도 합니다.\n초기 Kafka는 Zookeeper가 자주 죽어서 고생했다는 스터디원의 경험담을 들을 수 있었습니다.\nKafka 버전이 업데이트 될 수록 Zookeeper 안정성은 높아졌지만, Zookeeper로 인한 복잡도 증가 때문에 Kraft 전환 작업을 진행하고 있습니다.\nKraft 릴리즈 내역을 소개한 공식 문서입니다.\nKIP-833: Mark KRaft as Production Ready https://cwiki.apache.org/confluence/display/KAFKA/KIP-833%3A+Mark+KRaft+as+Production+Ready\nKafka가 Zookeeper에서 Kraft로 전환한 이유를 소개한 글입니다.\nKafka’s Shift from ZooKeeper to Kraft\nhttps://www.baeldung.com/kafka-shift-from-zookeeper-to-kraft\n분산 시스템에서 하드웨어 장애는 언제든지 발생할 수 있습니다.\n데이터 유실을 막고 가용성을 보장하기 위해 복제(Replication)를 제공해야 합니다.\n리더 파티션과 사본 파티션이 있으며 리더와 사본은 서로 다른 브로커에 존재합니다.\n프로듀서는 리더 파티션에게만 메시지를 발행합니다.\n사본 파티션은 리더 파티션을 동기화합니다.\n리더 파티션은 사본 파티션의 동기화를 체크하고 프로듀서에 메시지 수신 응답(Ack)을 합니다.\nAck 설정은 메시지큐의 성능과 영속성 사이에서 타협을 해야합니다.\nAck=all 모든 사본 파티션이 동기화를 해야하므로 메시지 유실 없음 느린 응답 송금, 주문 등 데이터가 유실되면 안되는 경우 Ack=1 리더 파티션이 메시지를 저장하고 Ack를 하므로 리더 파티션 장애 발생 시 메시지 유실 핫딜 앱 푸시 메시지 같이 일정 부분 유실을 감수하더라도, 대량 처리가 필요한 경우 Ack=0 Ack를 기다리지 않으므로 언제든지 메시지 유실 발생 가능 빠른 응답 로그, 지표 등 데이터가 유실되도 상관 없는 경우 메시지 큐는 시스템 특성상 분산 시스템일 수밖에 없습니다.\n단기간에 메시지가 급증해도 처리가 가능해야 합니다.\n주요 컴포넌트 관점에서 규모 확장성을 어떻게 달성할 수 있을지 생각해봅시다.\n프로듀서 메시지를 생산하는 프로듀서는 사용량(트래픽)에 따라 프로듀서를 추가하거나 삭제함으로써 규모 확장성을 달성할 수 있습니다.\n컨슈머 메시지 처리량보다 생산량이 많다면, 컨슈머를 추가하여 처리량을 늘려야 합니다.\n컨슈머가 추가/삭제되면 리밸런싱이 발생하며, 메시지 큐 설정에 따라 사이드 이펙트가 발생할 수 있으므로 주의해야 합니다.\n카프카 컨슈머 리밸런싱을 소개한 여기어때 기술블로그 입니다.\n카프카 컨슈머 그룹 리밸런싱 (Kafka Consumer Group Rebalancing)\nhttps://techblog.gccompany.co.kr/%EC%B9%B4%ED%94%84%EC%B9%B4-%EC%BB%A8%EC%8A%88%EB%A8%B8-%EA%B7%B8%EB%A3%B9-%EB%A6%AC%EB%B0%B8%EB%9F%B0%EC%8B%B1-kafka-consumer-group-rebalancing-5d3e3b916c9e\n브로커 브로커 내부에는 토픽의 리더 파티션과 사본 파티션이 존재하며, 실제 데이터가 기록된 WAL을 저장하고 있습니다.\n따라서 브로커가 추가/삭제될 경우 데이터 유실 없이 사본을 어떻게 분산할지 계획을 세워야 합니다.\n파티션 파티션 당 한 개의 컨슈머만 할당될 수 있으므로, 파티션과 컨슈머를 같은 수로 증가시켜야 합니다.\n파티션 수 조정은 비용이 큰 작업이므로 트래픽이 없는 시간대에 작업하는게 좋습니다.\n또한, 카프카 설정에 따라 메시지가 유실될 수 있으므로 주의해야 합니다.\n파티션 증가 시 auto.offset.reset 옵션 때문에 발생할 수 있는 사이드 이팩트와 해결방안을 소개한 블로그입니다.\n카프카 컨슈머의 auto.offset.reset 옵션을 반드시 earliest로 변경해야 하는 이유\nhttps://blog.voidmainvoid.net/514\nParallel Consumer를 소개한 네이버 기술블로그입니다.\nKafka에서 파티션 증가 없이 동시 처리량을 늘리는 방법 - Parallel Consumer\nhttps://d2.naver.com/helloworld/7181840\n메시지 큐를 사용하면 프로듀서와 컨슈머는 느슨한 결합 구조가 되어 서로 비동기적으로 수행합니다.\n따라서 메시지 전송의 신뢰성을 보장해야 하며, 메시지 큐의 성능(신뢰성↓)과 메시지 전송의 신뢰성(성능↓) 사이에서 선택할 수 있도록 메시지 전달 방식을 지원해야 합니다.\n일반적으로 메시지 큐는 세 가지 메시지 전달 방식이 있습니다.\n최대 한 번 (at-most once) 메시지를 최대 한 번만 전달하는 방식입니다.\n메시지가 전달 과정에서 소실되어도 다시 전달되는 일은 없습니다.\n프로듀서는 Ack=0 설정으로 메시지를 발행하고 수신응답을 기다리지 않습니다.\n메시지 전달이 실패해도 다시 시도하지 않습니다.\n컨슈머는 메시지를 읽고 처리하기 전에 오프셋부터 갱신합니다.\n메시지를 처리하기 전에 오프셋을 갱신하므로 처리 과정에서 장애/오류가 발생할 경우, 해당 메시지를 다시 소비할 수 없습니다.\n최소 한 번 (at-least once) 같은 메시지가 한 번 이상 전달될 수 있습니다.\n메시지 소실이 발생하지 않습니다.\n프로듀서는 Ack=1 또는 Ack=all 설정으로 메시지를 발행하고, 메시지가 브로커에 정상적으로 전달되었는지 반드시 확인합니다.\n메세지 전달이 실패하거나 타임아웃이 발생한 경우에는 계속 재시도 합니다.\n컨슈머는 메시지를 정상적으로 처리하고 오프셋을 갱신합니다.\n메시지 처리 과정에서 장애/오류가 발생하여도 해당 메시지를 다시 소비합니다.\n단, 메시지를 정상적으로 처리했으나 오프셋 갱신에 실패하면 중복 처리될 수 있으므로 컨슈머가 멱등적으로 처리할 수 있도록 구성해야 합니다.\n정확히 한 번 (exactly once) 정확히 한 번 (exactly once)는 프로듀서와 컨슈머 모두 멱등성을 보장해야 하는 구현이 가장 까다로운 방식입니다.\n메세지는 정확히 한 번 전달 되며 메시지 소실이 발생하지 않습니다.\nKafka 기준으로 프로듀서는 Ack=all과 idempotence=true, transactional.id=my-tx-id 설정으로 메시지의 유일성을 보장하여 발행합니다.\n메시지 큐만으로 정확히 한 번을 보장하기 어렵다면, InBox OutBox 패턴으로 도움을 줄 수 있습니다.\n정확히 한 번 (exactly once)은 스터디원 분들과 가장 많은 얘기를 나눌정도로 실제로 가능한 개념인지 의견이 분분했습니다.\n본 포스팅을 작성하기 위한 구글링 과정에서도 관련 내용으로 토론하는 게시물들을 꽤 볼 수 있었으며, 비현실적이다. 불가능하다. 라는 의견이 달리기도 했습니다.\n모든 것은 트레이드 오프를 동반하므로 정확히 한 번 (exactly once)을 달성하기 위해 값 비싼 비용을 지불해야할지 고민하는게 중요할 것 같습니다.\n아파치 카프카 Exactly-once 처리의 진실과 거짓\nhttps://blog.voidmainvoid.net/504\nKafka가 exactly once를 어떻게 달성하는지 소개하는 글입니다.\nExactly-Once Semantics Are Possible: Here’s How Kafka Does It\nhttps://www.confluent.io/blog/exactly-once-semantics-are-possible-heres-how-apache-kafka-does-it/\nInbox, Outbox 패턴을 소개하는 글입니다.\nOvercoming Message Delivery Challenges in Distributed Systems: A Comprehensive Look at Outbox and Inbox Patterns\nhttps://medium.com/hprog99/overcoming-message-delivery-challenges-in-distributed-systems-a-comprehensive-look-at-outbox-and-a669e5f21898\n일 3,000만 건의 네이버페이 주문 메시지를 처리하는 Kafka 시스템의 무중단 전환 사례\nhttps://d2.naver.com/helloworld/9581727\n","wordCount":"1208","inLanguage":"en","image":"https://team-json-delivery.github.io/images/message-queue/cover.png","datePublished":"2024-02-27T09:00:00+09:00","dateModified":"2024-02-27T09:00:00+09:00","author":{"@type":"Person","name":"junho3"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://team-json-delivery.github.io/posts/%EB%B6%84%EC%82%B0-%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90/"},"publisher":{"@type":"Organization","name":"Team JSON Delivery","logo":{"@type":"ImageObject","url":"https://team-json-delivery.github.io/%3Clink%20/%20abs%20url%3E"}}}</script><script>function changeGiscusTheme(){const e=document.body.classList.contains("dark")?"dark":"light";function t(e){const t=document.querySelector("iframe.giscus-frame");if(!t)return;t.contentWindow.postMessage({giscus:e},"https://giscus.app")}t({setConfig:{theme:e}})}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?(document.body.classList.add("dark"),setTimeout(changeGiscusTheme,2e3)):localStorage.getItem("pref-theme")==="light"?(document.body.classList.remove("dark"),setTimeout(changeGiscusTheme,2e3)):window.matchMedia("(prefers-color-scheme: dark)").matches&&(document.body.classList.add("dark"),setTimeout(changeGiscusTheme,2e3))</script><header class=header><nav class=nav><div class=logo><a href=https://team-json-delivery.github.io/ accesskey=h title="Team JSON Delivery (Alt + H)"><img src=https://team-json-delivery.github.io/apple-touch-icon.png alt aria-label=logo height=35>Team JSON Delivery</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://team-json-delivery.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://team-json-delivery.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://team-json-delivery.github.io/author/ title=author><span>author</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://team-json-delivery.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://team-json-delivery.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent" style=word-break:keep-all>쓰지만 말고 직접 구현해보자! 분산 메시지큐!</h1><div class=post-meta><span title='2024-02-27 09:00:00 +0900 +0900'>2024년 02월 27일</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1208 words&nbsp;·&nbsp;junho3&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/%eb%b6%84%ec%82%b0-%eb%a9%94%ec%8b%9c%ec%a7%80-%ed%81%90.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><div id=figmask style=z-index:-1><img loading=eager src=https://team-json-delivery.github.io/images/message-queue/cover.png alt></div></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><ul><li></li></ul></li></ul></nav></div></details></div><div class=post-content><h1 id=쓰지만-말고-직접-구현해보자-분산-메시지큐>쓰지만 말고 직접 구현해보자! 분산 메시지큐!<a hidden class=anchor aria-hidden=true href=#쓰지만-말고-직접-구현해보자-분산-메시지큐>#</a></h1><p>MSA(Microservice Architecture)가 아키텍처 설계의 트랜드가 되면서 메시지 큐는 시스템 구성의 중요한 요소로 자리잡았습니다.<br>이번 글에서는 <code>가상 면접 사례로 배우는 대규모 시스템 설계 기초 2 4장 분산 메시지 큐</code>를 소개하려고 합니다.<br>분산 메시지 큐의 특징을 간단히 알아보고, 기본적인 요소를 설계해봅시다.<br>(메세지 큐를 구성하는 요소가 방대한 만큼 세부 개념에 대한 자세한 설명은 넘어가겠습니다.)</p><hr><p>본격적인 설계에 앞서 메시지 큐의 기능을 생각해봅시다.</p><pre tabindex=0><code>1. 프로듀서는 메시지 큐에 메시지를 보낼 수 있어야 합니다.  
2. 컨슈머는 메시지 큐를 통해 메시지를 수신할 수 있어야 합니다.  
3. 하나의 메시지를 서로 다른 컨슈머가 수신할 수 있어야 합니다.  
4. 메시지가 생산된 순서대로 소비될 수 있도록 순서를 보장해야 합니다.  
5. 오래된 이력 데이터는 삭제될 수 있습니다.  
6. 메시지 크기는 킬로바이트 수준입니다.  
7. 메시지는 최소 한 번, 최대 한 번, 정확히 한 번 가운데 설정할 수 있어야 합니다.` 
</code></pre><p>메시지 큐의 비기능 요구사항은 3가지가 있습니다.</p><pre tabindex=0><code>1. 높은 대역폭과 낮은 전송 지연 중 하나를 설정으로 선택 가능해야 합니다.  
2. 메시지 양이 급증해도 처리 가능해야 합니다.  
3. 데이터는 디스크에 보관되어야 하며 여러 노드에 복제되어야 합니다.  
</code></pre><blockquote><p>Kafka와 RabbitMQ의 차이점은 무엇인가요?<br><a href=https://aws.amazon.com/ko/compare/the-difference-between-rabbitmq-and-kafka/>https://aws.amazon.com/ko/compare/the-difference-between-rabbitmq-and-kafka/</a></p></blockquote><blockquote><p>메시지큐와 Kafka의 기본적인 특징을 소개한 블로그입니다.<br>카프카가 무엇이고, 왜 사용하는 것 일까?<br><a href=https://hudi.blog/what-is-kafka/>https://hudi.blog/what-is-kafka/</a></p></blockquote><hr><p>다음으로 프로듀서에서 발행한 메시지가 컨슈머까지 어떻게 전달되는지 흐름을 생각해봅시다.<br>책에서는 <code>일대일 모델</code>부터 단계적으로 소개하고 있지만, 이 글에서는 <code>발행(Pub)-구독(Sub) 모델</code> 기반의 최종 모습만 소개하겠습니다.</p><p><img loading=lazy src=/images/message-queue/flow.png alt=flow.png></p><pre tabindex=0><code>1. 주문 서비스(프로듀서)가 주문완료 이벤트 메시지를 발행합니다.  
2. 메시지가 주문완료 토픽에 도착합니다.  
3. 토픽에 도착한 메시지는 라운드 로빈 등의 방식으로 파티션에 분배됩니다.  
4. 주문완료 토픽을 구독하고 있는 배송 컨슈머와 주문완료 알림톡 컨슈머는 수신 받은 메시지를 처리합니다.  
</code></pre><p>위 이미지와 같이 프로듀서가 토픽에 메시지를 발행하고, 컨슈머 그룹이 토픽(파티션)의 메시지를 구독한다면 요구사항 1~3번을 달성할 수 있습니다.<br>한 가지 중요하게 생각해볼 것은 <code>브로커가 메시지를 컨슈머에게 보낼 것(푸시 모델)</code>인가 아니면 <code>컨슈머가 브로커에서 가져갈 것(풀 모델)</code> 인지입니다.<br><code>푸시 모델(RabbitMQ, ActiveMQ)</code>과 <code>풀 모델(Kafka)</code>은 각각 장단점이 있어 요구사항에 적합한 모델 선택이 중요합니다.</p><blockquote><p>발행-구독 모델<br><a href=https://ko.wikipedia.org/wiki/%EB%B0%9C%ED%96%89-%EA%B5%AC%EB%8F%85_%EB%AA%A8%EB%8D%B8>https://ko.wikipedia.org/wiki/%EB%B0%9C%ED%96%89-%EA%B5%AC%EB%8F%85_%EB%AA%A8%EB%8D%B8</a></p></blockquote><hr><p>메시지의 순서는 어떻게 보장할 수 있을까요?</p><p>파티션은 FIFO 큐처럼 동작하므로 같은 파티션 안에서는 메시지 순서를 보장할 수 있습니다.<br>하지만 토픽 관점에서는 순서를 보장할 수 없기 때문에 메시지에 키를 할당해야 합니다.</p><p><img loading=lazy src=/images/message-queue/message-key.png alt=message-key.png></p><p>위 이미지처럼 같은 키를 가진 메시지를 같은 파티션으로 보낸다면 키를 가진 메시지는 순서를 보장할 수 있게 됩니다.<br>물론, 메시지 키를 할당하여도 토픽 관점에서 완벽한 순서 보장은 어렵습니다.<br>한 스터디원에 따르면, 컨슈머는 메시지를 DB에 적재하고 별도 배치 등으로 DB에 적재 된 데이터를 기준 시간 순으로 정렬하여 처리한 경험을 공유해주셨습니다.</p><hr><p>데이터의 장기 보관 요구사항을 만족하면서 높은 대역폭을 제공하려면 데이터 저장소와 적재 방식을 고민해야 합니다.</p><p>메시지 큐는 읽기와 쓰기가 대규모로 빈번하게 일어나기 때문에 파일에 저장하는 것이 적합합니다.<br>책에서는 <code>쓰기 우선 로그(Write-Ahead Log, WAL)</code>을 소개하고 있는데, 새로운 항목이 추가되기만 하는 일반적인 파일 구조입니다.<br>또한, 파일이 무한정 커질 것을 대비하여 <code>세그먼트 단위</code>로 파일을 분할해야 합니다.</p><p><img loading=lazy src=/images/message-queue/storage.png alt=storage.png></p><p>위와 같이 토픽의 파티션 하위에 세그먼트별로 WAL을 관리한다면, 용량 한계에 도달하거나 보관 기간이 만료된 오래된 세그먼트 파일을 삭제할 수 있습니다.</p><p>책에서는 <code>회전 디스크 사용</code>과 <code>배치 처리</code> 등 I/O를 줄이는 방법도 소개하고 있습니다.</p><hr><p>메시지 큐는 내부적으로 다양한 메타 정보를 관리해야 합니다.</p><pre tabindex=0><code>- 파티션에 할당된 컨슈머 정보  
- 컨슈머가 읽어간 마지막 메시지의 오프셋  
- 토픽 설정이나 속성 정보  
- 메시지 및 사본 등 기타 정보  
</code></pre><p>위와 같은 정보들은 높은 일관성을 요구하므로 <code>Apache ZooKeeper</code> 같은 키-값 저장소를 고려하는 것이 적합합니다.<br>또한, 주키퍼는 <code>브로커의 리더 선출</code> 과정을 돕기도 합니다.</p><p><img loading=lazy src=/images/message-queue/zookeeper.png alt=zookeeper.png></p><p>초기 Kafka는 Zookeeper가 자주 죽어서 고생했다는 스터디원의 경험담을 들을 수 있었습니다.<br>Kafka 버전이 업데이트 될 수록 Zookeeper 안정성은 높아졌지만, Zookeeper로 인한 복잡도 증가 때문에 Kraft 전환 작업을 진행하고 있습니다.</p><blockquote><p>Kraft 릴리즈 내역을 소개한 공식 문서입니다.<br>KIP-833: Mark KRaft as Production Ready
<a href=https://cwiki.apache.org/confluence/display/KAFKA/KIP-833%3A+Mark+KRaft+as+Production+Ready>https://cwiki.apache.org/confluence/display/KAFKA/KIP-833%3A+Mark+KRaft+as+Production+Ready</a></p></blockquote><blockquote><p>Kafka가 Zookeeper에서 Kraft로 전환한 이유를 소개한 글입니다.<br>Kafka’s Shift from ZooKeeper to Kraft<br><a href=https://www.baeldung.com/kafka-shift-from-zookeeper-to-kraft>https://www.baeldung.com/kafka-shift-from-zookeeper-to-kraft</a></p></blockquote><hr><p>분산 시스템에서 하드웨어 장애는 언제든지 발생할 수 있습니다.<br>데이터 유실을 막고 가용성을 보장하기 위해 <code>복제(Replication)</code>를 제공해야 합니다.</p><p><img loading=lazy src=/images/message-queue/replication.png alt=replication.png></p><p>리더 파티션과 사본 파티션이 있으며 리더와 사본은 서로 다른 브로커에 존재합니다.<br>프로듀서는 리더 파티션에게만 메시지를 발행합니다.<br>사본 파티션은 리더 파티션을 동기화합니다.<br>리더 파티션은 사본 파티션의 동기화를 체크하고 프로듀서에 <code>메시지 수신 응답(Ack)</code>을 합니다.</p><p>Ack 설정은 메시지큐의 성능과 영속성 사이에서 타협을 해야합니다.</p><ul><li><code>Ack=all</code><ul><li>모든 사본 파티션이 동기화를 해야하므로 메시지 유실 없음</li><li>느린 응답</li><li>송금, 주문 등 데이터가 유실되면 안되는 경우</li></ul></li><li><code>Ack=1</code><ul><li>리더 파티션이 메시지를 저장하고 Ack를 하므로 리더 파티션 장애 발생 시 메시지 유실</li><li>핫딜 앱 푸시 메시지 같이 일정 부분 유실을 감수하더라도, 대량 처리가 필요한 경우</li></ul></li><li><code>Ack=0</code><ul><li>Ack를 기다리지 않으므로 언제든지 메시지 유실 발생 가능</li><li>빠른 응답</li><li>로그, 지표 등 데이터가 유실되도 상관 없는 경우</li></ul></li></ul><hr><p>메시지 큐는 시스템 특성상 분산 시스템일 수밖에 없습니다.<br>단기간에 메시지가 급증해도 처리가 가능해야 합니다.<br>주요 컴포넌트 관점에서 규모 확장성을 어떻게 달성할 수 있을지 생각해봅시다.</p><h4 id=프로듀서>프로듀서<a hidden class=anchor aria-hidden=true href=#프로듀서>#</a></h4><p>메시지를 생산하는 프로듀서는 사용량(트래픽)에 따라 프로듀서를 추가하거나 삭제함으로써 규모 확장성을 달성할 수 있습니다.</p><h4 id=컨슈머>컨슈머<a hidden class=anchor aria-hidden=true href=#컨슈머>#</a></h4><p>메시지 처리량보다 생산량이 많다면, 컨슈머를 추가하여 처리량을 늘려야 합니다.<br>컨슈머가 추가/삭제되면 리밸런싱이 발생하며, 메시지 큐 설정에 따라 사이드 이펙트가 발생할 수 있으므로 주의해야 합니다.</p><blockquote><p>카프카 컨슈머 리밸런싱을 소개한 여기어때 기술블로그 입니다.<br>카프카 컨슈머 그룹 리밸런싱 (Kafka Consumer Group Rebalancing)<br><a href=https://techblog.gccompany.co.kr/%EC%B9%B4%ED%94%84%EC%B9%B4-%EC%BB%A8%EC%8A%88%EB%A8%B8-%EA%B7%B8%EB%A3%B9-%EB%A6%AC%EB%B0%B8%EB%9F%B0%EC%8B%B1-kafka-consumer-group-rebalancing-5d3e3b916c9e>https://techblog.gccompany.co.kr/%EC%B9%B4%ED%94%84%EC%B9%B4-%EC%BB%A8%EC%8A%88%EB%A8%B8-%EA%B7%B8%EB%A3%B9-%EB%A6%AC%EB%B0%B8%EB%9F%B0%EC%8B%B1-kafka-consumer-group-rebalancing-5d3e3b916c9e</a></p></blockquote><h4 id=브로커>브로커<a hidden class=anchor aria-hidden=true href=#브로커>#</a></h4><p>브로커 내부에는 토픽의 리더 파티션과 사본 파티션이 존재하며, 실제 데이터가 기록된 WAL을 저장하고 있습니다.<br>따라서 브로커가 추가/삭제될 경우 데이터 유실 없이 사본을 어떻게 분산할지 계획을 세워야 합니다.</p><h4 id=파티션>파티션<a hidden class=anchor aria-hidden=true href=#파티션>#</a></h4><p>파티션 당 한 개의 컨슈머만 할당될 수 있으므로, 파티션과 컨슈머를 같은 수로 증가시켜야 합니다.<br>파티션 수 조정은 비용이 큰 작업이므로 트래픽이 없는 시간대에 작업하는게 좋습니다.<br>또한, 카프카 설정에 따라 메시지가 유실될 수 있으므로 주의해야 합니다.</p><blockquote><p>파티션 증가 시 auto.offset.reset 옵션 때문에 발생할 수 있는 사이드 이팩트와 해결방안을 소개한 블로그입니다.<br>카프카 컨슈머의 auto.offset.reset 옵션을 반드시 earliest로 변경해야 하는 이유<br><a href=https://blog.voidmainvoid.net/514>https://blog.voidmainvoid.net/514</a></p></blockquote><blockquote><p>Parallel Consumer를 소개한 네이버 기술블로그입니다.<br>Kafka에서 파티션 증가 없이 동시 처리량을 늘리는 방법 - Parallel Consumer<br><a href=https://d2.naver.com/helloworld/7181840>https://d2.naver.com/helloworld/7181840</a></p></blockquote><hr><p>메시지 큐를 사용하면 프로듀서와 컨슈머는 느슨한 결합 구조가 되어 서로 비동기적으로 수행합니다.<br>따라서 메시지 전송의 신뢰성을 보장해야 하며, 메시지 큐의 성능(신뢰성↓)과 메시지 전송의 신뢰성(성능↓) 사이에서 선택할 수 있도록 메시지 전달 방식을 지원해야 합니다.<br>일반적으로 메시지 큐는 세 가지 메시지 전달 방식이 있습니다.</p><h4 id=최대-한-번-at-most-once>최대 한 번 (at-most once)<a hidden class=anchor aria-hidden=true href=#최대-한-번-at-most-once>#</a></h4><p>메시지를 최대 한 번만 전달하는 방식입니다.<br>메시지가 전달 과정에서 소실되어도 다시 전달되는 일은 없습니다.</p><p>프로듀서는 <code>Ack=0</code> 설정으로 메시지를 발행하고 수신응답을 기다리지 않습니다.<br>메시지 전달이 실패해도 다시 시도하지 않습니다.</p><p>컨슈머는 메시지를 읽고 처리하기 전에 오프셋부터 갱신합니다.<br>메시지를 처리하기 전에 오프셋을 갱신하므로 처리 과정에서 장애/오류가 발생할 경우, 해당 메시지를 다시 소비할 수 없습니다.</p><h4 id=최소-한-번-at-least-once>최소 한 번 (at-least once)<a hidden class=anchor aria-hidden=true href=#최소-한-번-at-least-once>#</a></h4><p>같은 메시지가 한 번 이상 전달될 수 있습니다.<br>메시지 소실이 발생하지 않습니다.</p><p>프로듀서는 <code>Ack=1</code> 또는 <code>Ack=all</code> 설정으로 메시지를 발행하고, 메시지가 브로커에 정상적으로 전달되었는지 반드시 확인합니다.<br>메세지 전달이 실패하거나 타임아웃이 발생한 경우에는 계속 재시도 합니다.</p><p>컨슈머는 메시지를 정상적으로 처리하고 오프셋을 갱신합니다.<br>메시지 처리 과정에서 장애/오류가 발생하여도 해당 메시지를 다시 소비합니다.<br>단, 메시지를 정상적으로 처리했으나 오프셋 갱신에 실패하면 중복 처리될 수 있으므로 컨슈머가 멱등적으로 처리할 수 있도록 구성해야 합니다.</p><h4 id=정확히-한-번-exactly-once>정확히 한 번 (exactly once)<a hidden class=anchor aria-hidden=true href=#정확히-한-번-exactly-once>#</a></h4><p><code>정확히 한 번 (exactly once)</code>는 프로듀서와 컨슈머 모두 멱등성을 보장해야 하는 구현이 가장 까다로운 방식입니다.<br>메세지는 정확히 한 번 전달 되며 메시지 소실이 발생하지 않습니다.</p><p>Kafka 기준으로 프로듀서는 <code>Ack=all</code>과 <code>idempotence=true</code>, <code>transactional.id=my-tx-id</code> 설정으로 메시지의 유일성을 보장하여 발행합니다.<br>메시지 큐만으로 정확히 한 번을 보장하기 어렵다면, <code>InBox OutBox 패턴</code>으로 도움을 줄 수 있습니다.</p><p><code>정확히 한 번 (exactly once)</code>은 스터디원 분들과 가장 많은 얘기를 나눌정도로 실제로 가능한 개념인지 의견이 분분했습니다.<br>본 포스팅을 작성하기 위한 구글링 과정에서도 관련 내용으로 토론하는 게시물들을 꽤 볼 수 있었으며, 비현실적이다. 불가능하다. 라는 의견이 달리기도 했습니다.<br>모든 것은 트레이드 오프를 동반하므로 <code>정확히 한 번 (exactly once)</code>을 달성하기 위해 값 비싼 비용을 지불해야할지 고민하는게 중요할 것 같습니다.</p><blockquote><p>아파치 카프카 Exactly-once 처리의 진실과 거짓<br><a href=https://blog.voidmainvoid.net/504>https://blog.voidmainvoid.net/504</a></p></blockquote><blockquote><p>Kafka가 exactly once를 어떻게 달성하는지 소개하는 글입니다.<br>Exactly-Once Semantics Are Possible: Here’s How Kafka Does It<br><a href=https://www.confluent.io/blog/exactly-once-semantics-are-possible-heres-how-apache-kafka-does-it/>https://www.confluent.io/blog/exactly-once-semantics-are-possible-heres-how-apache-kafka-does-it/</a></p></blockquote><blockquote><p>Inbox, Outbox 패턴을 소개하는 글입니다.<br>Overcoming Message Delivery Challenges in Distributed Systems: A Comprehensive Look at Outbox and Inbox Patterns<br><a href=https://medium.com/hprog99/overcoming-message-delivery-challenges-in-distributed-systems-a-comprehensive-look-at-outbox-and-a669e5f21898>https://medium.com/hprog99/overcoming-message-delivery-challenges-in-distributed-systems-a-comprehensive-look-at-outbox-and-a669e5f21898</a></p></blockquote><blockquote><p>일 3,000만 건의 네이버페이 주문 메시지를 처리하는 Kafka 시스템의 무중단 전환 사례<br><a href=https://d2.naver.com/helloworld/9581727>https://d2.naver.com/helloworld/9581727</a></p></blockquote></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://team-json-delivery.github.io/posts/metric-service/><span class=title>« Prev</span><br><span>모니터링, 알람 그리고 장애들 😊</span>
</a><a class=next href=https://team-json-delivery.github.io/posts/nearby-service/><span class=title>Next »</span><br><span>내 근처에는 누가 살고 있을까? : 위치 기반 서비스 설계하기</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 쓰지만 말고 직접 구현해보자! 분산 메시지큐! on x" href="https://x.com/intent/tweet/?text=%ec%93%b0%ec%a7%80%eb%a7%8c%20%eb%a7%90%ea%b3%a0%20%ec%a7%81%ec%a0%91%20%ea%b5%ac%ed%98%84%ed%95%b4%eb%b3%b4%ec%9e%90%21%20%eb%b6%84%ec%82%b0%20%eb%a9%94%ec%8b%9c%ec%a7%80%ed%81%90%21&amp;url=https%3a%2f%2fteam-json-delivery.github.io%2fposts%2f%25EB%25B6%2584%25EC%2582%25B0-%25EB%25A9%2594%25EC%258B%259C%25EC%25A7%2580-%25ED%2581%2590%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 쓰지만 말고 직접 구현해보자! 분산 메시지큐! on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fteam-json-delivery.github.io%2fposts%2f%25EB%25B6%2584%25EC%2582%25B0-%25EB%25A9%2594%25EC%258B%259C%25EC%25A7%2580-%25ED%2581%2590%2f&amp;title=%ec%93%b0%ec%a7%80%eb%a7%8c%20%eb%a7%90%ea%b3%a0%20%ec%a7%81%ec%a0%91%20%ea%b5%ac%ed%98%84%ed%95%b4%eb%b3%b4%ec%9e%90%21%20%eb%b6%84%ec%82%b0%20%eb%a9%94%ec%8b%9c%ec%a7%80%ed%81%90%21&amp;summary=%ec%93%b0%ec%a7%80%eb%a7%8c%20%eb%a7%90%ea%b3%a0%20%ec%a7%81%ec%a0%91%20%ea%b5%ac%ed%98%84%ed%95%b4%eb%b3%b4%ec%9e%90%21%20%eb%b6%84%ec%82%b0%20%eb%a9%94%ec%8b%9c%ec%a7%80%ed%81%90%21&amp;source=https%3a%2f%2fteam-json-delivery.github.io%2fposts%2f%25EB%25B6%2584%25EC%2582%25B0-%25EB%25A9%2594%25EC%258B%259C%25EC%25A7%2580-%25ED%2581%2590%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 쓰지만 말고 직접 구현해보자! 분산 메시지큐! on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fteam-json-delivery.github.io%2fposts%2f%25EB%25B6%2584%25EC%2582%25B0-%25EB%25A9%2594%25EC%258B%259C%25EC%25A7%2580-%25ED%2581%2590%2f&title=%ec%93%b0%ec%a7%80%eb%a7%8c%20%eb%a7%90%ea%b3%a0%20%ec%a7%81%ec%a0%91%20%ea%b5%ac%ed%98%84%ed%95%b4%eb%b3%b4%ec%9e%90%21%20%eb%b6%84%ec%82%b0%20%eb%a9%94%ec%8b%9c%ec%a7%80%ed%81%90%21"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 쓰지만 말고 직접 구현해보자! 분산 메시지큐! on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fteam-json-delivery.github.io%2fposts%2f%25EB%25B6%2584%25EC%2582%25B0-%25EB%25A9%2594%25EC%258B%259C%25EC%25A7%2580-%25ED%2581%2590%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 쓰지만 말고 직접 구현해보자! 분산 메시지큐! on whatsapp" href="https://api.whatsapp.com/send?text=%ec%93%b0%ec%a7%80%eb%a7%8c%20%eb%a7%90%ea%b3%a0%20%ec%a7%81%ec%a0%91%20%ea%b5%ac%ed%98%84%ed%95%b4%eb%b3%b4%ec%9e%90%21%20%eb%b6%84%ec%82%b0%20%eb%a9%94%ec%8b%9c%ec%a7%80%ed%81%90%21%20-%20https%3a%2f%2fteam-json-delivery.github.io%2fposts%2f%25EB%25B6%2584%25EC%2582%25B0-%25EB%25A9%2594%25EC%258B%259C%25EC%25A7%2580-%25ED%2581%2590%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 쓰지만 말고 직접 구현해보자! 분산 메시지큐! on telegram" href="https://telegram.me/share/url?text=%ec%93%b0%ec%a7%80%eb%a7%8c%20%eb%a7%90%ea%b3%a0%20%ec%a7%81%ec%a0%91%20%ea%b5%ac%ed%98%84%ed%95%b4%eb%b3%b4%ec%9e%90%21%20%eb%b6%84%ec%82%b0%20%eb%a9%94%ec%8b%9c%ec%a7%80%ed%81%90%21&amp;url=https%3a%2f%2fteam-json-delivery.github.io%2fposts%2f%25EB%25B6%2584%25EC%2582%25B0-%25EB%25A9%2594%25EC%258B%259C%25EC%25A7%2580-%25ED%2581%2590%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 쓰지만 말고 직접 구현해보자! 분산 메시지큐! on ycombinator" href="https://news.ycombinator.com/submitlink?t=%ec%93%b0%ec%a7%80%eb%a7%8c%20%eb%a7%90%ea%b3%a0%20%ec%a7%81%ec%a0%91%20%ea%b5%ac%ed%98%84%ed%95%b4%eb%b3%b4%ec%9e%90%21%20%eb%b6%84%ec%82%b0%20%eb%a9%94%ec%8b%9c%ec%a7%80%ed%81%90%21&u=https%3a%2f%2fteam-json-delivery.github.io%2fposts%2f%25EB%25B6%2584%25EC%2582%25B0-%25EB%25A9%2594%25EC%258B%259C%25EC%25A7%2580-%25ED%2581%2590%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://giscus.app/client.js data-repo=team-json-delivery/team-json-delivery.github.io data-repo-id=R_kgDOLAMZNQ data-category=comment data-category-id=DIC_kwDOLAMZNc4CcJ4o data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=ko crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://team-json-delivery.github.io/>Team JSON Delivery</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light"),changeGiscusTheme()):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"),changeGiscusTheme())})</script></body></html>